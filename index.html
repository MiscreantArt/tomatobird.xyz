<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>Ether Dash</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background: #000;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameContainer {
            width: 100vw;
            height: 100dvh; /* Use dynamic viewport height for mobile Safari */
            display: flex;
            justify-content: center;
            align-items: center; /* Center canvas vertically on all phones */
            background: #000;
        }

        canvas {
            display: block;
            background: #1a0033;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
            font-size: 12px;
            z-index: 1000;
        }

        .loading-text {
            margin-top: 20px;
        }

        .loading-bar {
            width: 200px;
            height: 20px;
            border: 2px solid #0ff;
            margin-top: 10px;
            position: relative;
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #f0f);
            width: 0%;
            transition: width 0.3s;
        }

        .glow {
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
        }
    </style>
</head>
<body style="background:#000;margin:0;overflow:hidden;">
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="loadingScreen">
        <div class="glow" style="font-size: 20px;">ETHER DASH</div>
        <div class="loading-text">Loading...</div>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
    </div>

    <script>
        // ==========================================
        // ETHER DASH - Mobile Runner Game
        // ==========================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingFill = document.getElementById('loadingFill');

        // Canvas setup â€” use full screen in portrait, cap at 9:16 in landscape
        const MAX_RATIO = 9 / 16; // widest allowed (portrait)
        function resizeCanvas() {
            const winW = window.innerWidth;
            const winH = window.innerHeight * 0.95;

            let cw, ch;
            const ratio = winW / winH;

            if (ratio > MAX_RATIO) {
                // Landscape or too wide â€” letterbox to 9:16
                ch = winH;
                cw = Math.round(ch * MAX_RATIO);
            } else {
                // Portrait phone â€” use full width, no bars
                cw = winW;
                ch = winH;
            }

            canvas.width = cw;
            canvas.height = ch;
            canvas.style.width = cw + 'px';
            canvas.style.height = ch + 'px';
            canvas.style.position = 'absolute';
            canvas.style.left = Math.round((winW - cw) / 2) + 'px';
            canvas.style.top = Math.round((window.innerHeight * 0.95 - ch) / 2) + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==========================================
        // GAME STATE
        // ==========================================

        const GAME_STATE = {
            LOADING: 'loading',
            TITLE: 'title',
            HOW_TO_PLAY: 'howToPlay',
            CHOOSE_BIRD: 'chooseBird',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver',
            HIGH_SCORES: 'highScores',
            ENTER_INITIALS: 'enterInitials'
        };

        // ==========================================
        // MOONBIRD CHOOSER STATE
        // ==========================================
        const MOONBIRD_CDN = 'https://pub-a04e3d2e363a40bab58b0c80a73ae92c.r2.dev';
        // Will become: 'https://sprites.tomatobird.xyz'
        
        const MISCREANT_BIRD_ID = 2779;

        // Reserved names â€” can't be used for custom bird names
        const RESERVED_NAMES = {
            2779: 'MISCREANT',
            420: 'SNOOP BIRD',
            69: 'NICE',
            1337: 'L33T',
            0: 'GENESIS',
            9999: 'FINAL BOSS',
            42: 'HITCHHIKER',
            666: 'HELL BIRD',
            8008: 'CLASSIC',
            7777: 'JACKPOT',
            8209: 'JK',
            649: 'BARMAN',
            1056: 'MOSTMETA'
        };

        // 3 save slots + active selection
        let moonbirdState = {
            selectedId: MISCREANT_BIRD_ID,
            inputDigits: '',
            previewSprites: null,
            previewLoading: false,
            cursorBlink: 0,
            inputFresh: true,  // true = next digit clears field first
            slots: [null, null, null],  // {id, name} or null
            namingMode: false,  // true when naming a bird for a slot
            namingSlot: -1,     // which slot we're naming for
            namingText: '',     // current name being typed
        };

        // Load save slots from localStorage
        try {
            const savedSlots = JSON.parse(localStorage.getItem('moonbirdSlots'));
            if (Array.isArray(savedSlots)) moonbirdState.slots = savedSlots;
        } catch(e) {}

        // Load active selection from localStorage
        const savedBird = localStorage.getItem('selectedMoonbird');
        if (savedBird) {
            moonbirdState.selectedId = parseInt(savedBird);
        }

        function getMoonbirdDisplayName() {
            const id = moonbirdState.selectedId;
            if (RESERVED_NAMES[id]) return RESERVED_NAMES[id];
            // Check if saved in a slot with a custom name
            for (const slot of moonbirdState.slots) {
                if (slot && slot.id === id && slot.name) return slot.name;
            }
            return `MOONBIRD #${id}`;
        }

        function saveMoonbirdSelection() {
            localStorage.setItem('selectedMoonbird', moonbirdState.selectedId.toString());
        }

        function saveMoonbirdSlots() {
            localStorage.setItem('moonbirdSlots', JSON.stringify(moonbirdState.slots));
        }

        function isReservedName(name) {
            const upper = name.toUpperCase().trim();
            if (upper.length === 0) return true;
            for (const rn of Object.values(RESERVED_NAMES)) {
                if (upper === rn) return true;
            }
            return false;
        }

        // Load moonbird sprites into the main game assets (replaces owl sprites)
        async function loadMoonbirdGameSprites(id) {
            if (id === null) return; // keep original owl
            const cdnBase = `${MOONBIRD_CDN}/${id}`;
            
            // Mapping: R2 sprite name â†’ game asset key
            // east_idle_1-6.png (side-facing bounce) â†’ jump1-jump6 (in-game idle + jumping)
            // walk_1-6.png (side-facing walking) â†’ walk1-walk6 (running)
            // idle_1-6.png (front-facing) â†’ look1-look6 (title screen, life icon)
            const mappings = [];
            for (let i = 1; i <= 6; i++) {
                mappings.push({ url: `${cdnBase}/east_idle_${i}.png`, keys: [`jump${i}`] });
                mappings.push({ url: `${cdnBase}/walk_${i}.png`, keys: [`walk${i}`] });
                mappings.push({ url: `${cdnBase}/idle_${i}.png`, keys: [`look${i}`] });
            }

            const results = await Promise.allSettled(mappings.map(m => 
                new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve({ img, keys: m.keys });
                    img.onerror = () => reject(m.url);
                    img.src = m.url;
                })
            ));

            let loaded = 0;
            results.forEach(r => {
                if (r.status === 'fulfilled') {
                    r.value.keys.forEach(key => { assets.images[key] = r.value.img; });
                    loaded++;
                }
            });

            console.log(`Moonbird #${id}: loaded ${loaded}/12 sprite sets`);
            // If any failed, the original owl sprites remain as fallback for those frames
        }

        // Load moonbird preview sprites for the chooser screen
        async function loadMoonbirdPreview(id) {
            if (id === null) { moonbirdState.previewSprites = null; return; }
            moonbirdState.previewLoading = true;
            const sprites = {};
            const names = ['idle_1', 'idle_2', 'idle_3', 'idle_4', 'idle_5', 'idle_6'];
            try {
                await Promise.all(names.map(name => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => { sprites[name] = img; resolve(); };
                    img.onerror = () => reject();
                    img.src = `${MOONBIRD_CDN}/${id}/${name}.png`;
                })));
                moonbirdState.previewSprites = sprites;
            } catch(e) {
                moonbirdState.previewSprites = null;
            }
            moonbirdState.previewLoading = false;
        }

        let currentState = GAME_STATE.LOADING;

        // ==========================================
        // ASSET LOADING
        // ==========================================

        const assets = {
            images: {},
            audio: {},
            loaded: 0,
            total: 0
        };

        const imagesToLoad = {
            background: 'Background.png',
            title: 'Title.jpg',
            ethCoin: 'EthCoin.png',
            drainer: 'Drainer.png',
            drainer2: 'Drainer2.png',
            coinSprite: 'sprites/coin.png',
            cashoutSprite: 'sprites/cashout.png',
            jump1: 'sprites/Jump 1.png',
            jump2: 'sprites/Jump 2.png',
            jump3: 'sprites/Jump 3.png',
            jump4: 'sprites/Jump 4.png',
            jump5: 'sprites/Jump 5.png',
            jump6: 'sprites/Jump 6.png',
            walk1: 'sprites/walk_1.png',
            walk2: 'sprites/walk_2.png',
            walk3: 'sprites/walk_3.png',
            walk4: 'sprites/walk_4.png',
            walk5: 'sprites/walk_5.png',
            walk6: 'sprites/walk_6.png',
            look1: 'sprites/look_1.png',
            look2: 'sprites/look_2.png',
            look3: 'sprites/look_3.png',
            look4: 'sprites/look_4.png',
            look5: 'sprites/look_5.png',
            look6: 'sprites/look_6.png'
        };

        const audioToLoad = {
            coin: 'audio/Coin.mp3',
            drain: 'audio/Drain.mp3',
            jump: 'audio/Jump.mp3',
            money: 'audio/Money.mp3',
            bgMusic: 'audio/Ether M1.mp3',
            hiScoreMusic: 'audio/HiS.mp3',
            textSound: 'audio/Text.mp3'
        };

        assets.total = Object.keys(imagesToLoad).length + Object.keys(audioToLoad).length;

        function updateLoadingBar() {
            const percent = (assets.loaded / assets.total) * 100;
            loadingFill.style.width = percent + '%';

            if (assets.loaded === assets.total) {
                
                // Pre-load saved moonbird sprites so title screen shows the right bird
                loadMoonbirdGameSprites(moonbirdState.selectedId).then(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    currentState = GAME_STATE.TITLE;
                });
            }
        }

        // Load images
        Object.keys(imagesToLoad).forEach(key => {
            const img = new Image();
            img.onload = () => {
                assets.loaded++;
                updateLoadingBar();
            };
            img.onerror = () => {
                console.warn(`Failed to load image: ${imagesToLoad[key]}`);
                assets.loaded++;
                updateLoadingBar();
            };
            img.src = imagesToLoad[key];
            assets.images[key] = img;
        });

        // Load audio
        Object.keys(audioToLoad).forEach(key => {
            const audio = new Audio();
            audio.oncanplaythrough = () => {
                assets.loaded++;
                updateLoadingBar();
            };
            audio.onerror = () => {
                console.warn(`Failed to load audio: ${audioToLoad[key]}`);
                assets.loaded++;
                updateLoadingBar();
            };
            audio.src = audioToLoad[key];
            audio.load();
            assets.audio[key] = audio;
        });

        // Audio system - Web Audio API for sound effects
        let audioEnabled = false;
        let musicStarted = false;
        let audioCtx = null;
        const audioBuffers = {};
        const audioRawData = {};

        // Pre-fetch audio files immediately (no user gesture needed for fetch)
        const soundFiles = {
            jump: 'audio/Jump.mp3',
            coin: 'audio/Coin.mp3',
            drain: 'audio/Drain.mp3',
            money: 'audio/Money.mp3',
            textSound: 'audio/Text.mp3'
        };
        const fetchPromises = [];
        for (const [name, url] of Object.entries(soundFiles)) {
            const p = fetch(url).then(r => r.arrayBuffer()).then(buf => {
                audioRawData[name] = buf;
            }).catch(() => {});
            fetchPromises.push(p);
        }
        const allFetched = Promise.all(fetchPromises);

        async function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            // Wait for ALL sounds to be fetched, then decode all at once
            await allFetched;
            await decodeAllPending();
        }

        async function decodeAllPending() {
            if (!audioCtx) return;
            for (const [name, buf] of Object.entries(audioRawData)) {
                if (!audioBuffers[name]) {
                    try {
                        audioBuffers[name] = await audioCtx.decodeAudioData(buf.slice(0));
                    } catch(e) {
                        console.warn('Failed to decode sound:', name);
                    }
                }
            }
            // Check if all sounds are decoded
            const allDecoded = Object.keys(soundFiles).every(n => audioBuffers[n]);
        }

        function playSound(name) {
            if (!audioEnabled || !audioCtx) return;
            // Force resume if still suspended
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            // Synthesized shield block sound
            if (name === 'shieldBlock') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.2);
                return;
            }
            if (!audioBuffers[name]) {
                // Try late decode if raw data arrived after initAudio â€” play once ready
                if (audioRawData[name]) {
                    audioCtx.decodeAudioData(audioRawData[name].slice(0)).then(buf => {
                        audioBuffers[name] = buf;
                        const s = audioCtx.createBufferSource();
                        s.buffer = buf;
                        s.connect(audioCtx.destination);
                        s.start(0);
                    }).catch(() => {});
                }
                return;
            }
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffers[name];
            source.connect(audioCtx.destination);
            source.start(0);
        }

        function startMusic() {
            if (!audioEnabled || musicStarted) return;
            // Ensure AudioContext is active (required before any audio on mobile)
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const music = assets.audio.bgMusic;
            if (music) {
                music.loop = true;
                music.volume = 0.5;
                const tryPlay = () => {
                    music.play().then(() => {
                        musicStarted = true;
                    }).catch(e => {
                        console.warn('Music play failed, retrying in 500ms:', e);
                        setTimeout(tryPlay, 500);
                    });
                };
                tryPlay();
            }
        }

        function enableAudio() {
            if (!audioEnabled) {
                audioEnabled = true;
                // Create AudioContext synchronously in user gesture (Chrome requirement)
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                // No unlock needed â€” spawn delay gives Chrome time to warm up
            }
            // Chrome suspends AudioContext until user gesture â€” MUST resume first
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    decodeAllPending();
                    allFetched.then(() => decodeAllPending());
                });
            } else if (audioCtx) {
                decodeAllPending();
                allFetched.then(() => decodeAllPending());
            }
        }

        // Audio context created on first user gesture (enableAudio), raw files pre-fetched above

        // ==========================================
        // GAME VARIABLES
        // ==========================================

        // Physics constants - matching iOS original
        const PHYSICS = {
            GRAVITY: 0.9,
            JUMP_FORCE: -20,
            GAME_AREA_RATIO: 0.9,  // Top 90% is game area  
            HOLD_ZONE_RATIO: 0.1,  // Bottom 10% is hold zone
            GROUND_Y_RATIO: 0.81,  // Owl feet on railing
            PLAYER_X_RATIO: 0.3,   // Player at 30% from left
            WALK_SPEED_MULTIPLIER: 1,  // Direct speed when walking (applied to base walk speed)
            IDLE_SPEED: 0,  // No scroll when idle â€” owl only moves when you hold
            JUMP_SPEED_MULTIPLIER: 1.0  // Same speed as running
        };

        let gameState = {
            score: 0,
            coinsCollected: 0,  // Track coins separately from score
            lives: 3,  // Lives system
            combo: 0,
            comboMultiplier: 1,
            shieldCount: 0,  // 0=none, 1=single shield, 2=double shield
            invincibleTimer: 0,  // i-frames after taking damage (ms)
            coinRainTimer: 0,  // coin rain powerup duration (ms)
            magnet: false,
            magnetTimer: 0,
            bgScroll: 0,
            bgSpeed: PHYSICS.IDLE_SPEED,
            playerY: 0,  // Actual Y position
            playerVelocityY: 0,  // Vertical velocity
            playerX: 0,  // Fixed X position (30% from left)
            grounded: true,
            isHolding: false,  // CRITICAL: track if player is holding
            isWalking: false,  // Track walking state
            playerAnimFrame: 0,
            playerAnimTimer: 0,
            walkAnimSpeed: 0.07,  // timePerFrame for walk
            jumpAnimSpeed: 0.1,   // timePerFrame for jump
            objects: [],
            particles: [],
            screenShake: 0,
            lastSpawnTime: 0,
            spawnInterval: 400,  // Fast spawns â€” screen full of coins
            gameTime: 0,
            drainersEnabled: false,
            highScores: [],
            lastDrainerX: -1000,
            milestoneReached: 0,
            newHighScoreIndex: -1,  // For highlighting new score
            compromiseMessage: '',  // Current compromise message
            compromiseMessageLife: 0,  // Life timer for message
            milestoneFlash: 0  // White flash for milestone celebrations
        };

        // Get ground level Y position
        function getGroundY() {
            return canvas.height * PHYSICS.GROUND_Y_RATIO;
        }

        // Get player size (larger than before - 2.1x scale like original)
        function getPlayerSize() {
            return Math.min(canvas.height * 0.13, 120);  // Bigger owl
        }

        // ==========================================
        // HIGH SCORE SYSTEM
        // ==========================================

        const HIGH_SCORE_COLORS = [
            '#ff0000',  // red
            '#00ff00',  // green
            '#ffff00',  // yellow
            '#0000ff',  // blue
            '#00ffff',  // cyan
            '#ff00ff',  // magenta
            '#ff8800',  // orange
            '#8800ff',  // purple
            '#884400',  // brown
            '#aaaaaa'   // lightGray
        ];

        const LEADERBOARD_URL = 'https://tomatobird.xyz/api/scores';

        function loadHighScores() {
            // Load local scores first (instant)
            const saved = localStorage.getItem('etherDashHighScores');
            if (saved) {
                gameState.highScores = JSON.parse(saved);
            } else {
                gameState.highScores = [];
            }

            // Then fetch global scores and merge
            fetch(LEADERBOARD_URL)
                .then(r => r.json())
                .then(globalScores => {
                    if (Array.isArray(globalScores)) {
                        // Merge local and global, dedupe, keep top 10
                        const all = [...gameState.highScores, ...globalScores];
                        const seen = new Set();
                        const unique = all.filter(e => {
                            const key = e.initials + ':' + e.score;
                            if (seen.has(key)) return false;
                            seen.add(key);
                            return true;
                        });
                        unique.sort((a, b) => b.score - a.score);
                        gameState.highScores = unique.slice(0, 10);
                        saveHighScores();
                    }
                })
                .catch(() => {}); // silently fail â€” local scores still work
        }

        function saveHighScores() {
            localStorage.setItem('etherDashHighScores', JSON.stringify(gameState.highScores));
        }

        function addHighScore(initials, score) {
            gameState.highScores.push({ initials, score, date: Date.now() });
            gameState.highScores.sort((a, b) => b.score - a.score);
            gameState.highScores = gameState.highScores.slice(0, 10);

            // Find the index of the new score
            gameState.newHighScoreIndex = gameState.highScores.findIndex(entry =>
                entry.initials === initials && entry.score === score
            );

            saveHighScores();

            // Submit to global leaderboard (atomic â€” server handles merge)
            fetch(LEADERBOARD_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ initials, score })
            })
            .then(r => r.json())
            .then(data => {
                if (data.scores) {
                    gameState.highScores = data.scores;
                    saveHighScores();
                }
            })
            .catch(() => {});
        }

        function isHighScore(score) {
            return gameState.highScores.length < 10 || score > gameState.highScores[gameState.highScores.length - 1].score;
        }

        loadHighScores();

        // ==========================================
        // INITIALS INPUT SYSTEM
        // ==========================================

        let initialsInput = {
            letters: ['A', 'A', 'A'],
            currentIndex: 0,
            blinkTimer: 0
        };

        function cycleInitialLetter(index) {
            const current = initialsInput.letters[index];
            const charCode = current.charCodeAt(0);
            if (charCode >= 90) {  // Z wraps to A
                initialsInput.letters[index] = 'A';
            } else {
                initialsInput.letters[index] = String.fromCharCode(charCode + 1);
            }
            playSound('textSound');
        }

        // Music management
        function stopMusic() {
            musicStarted = false;
            const music = assets.audio.bgMusic;
            if (music) { music.pause(); music.currentTime = 0; }
            const hsMusic = assets.audio.hiScoreMusic;
            if (hsMusic) { hsMusic.pause(); hsMusic.currentTime = 0; }
        }

        // Pause all audio when tab/app is hidden (switching apps, locking phone)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const music = assets.audio.bgMusic;
                if (music && !music.paused) music.pause();
                const hsMusic = assets.audio.hiScoreMusic;
                if (hsMusic && !hsMusic.paused) hsMusic.pause();
                if (audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            } else {
                // Resume when coming back
                if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
                if (currentState === GAME_STATE.PLAYING && musicStarted) {
                    const music = assets.audio.bgMusic;
                    if (music && music.paused) music.play().catch(() => {});
                } else if (currentState === GAME_STATE.GAME_OVER || currentState === GAME_STATE.HIGH_SCORES || currentState === GAME_STATE.ENTER_INITIALS) {
                    const hsMusic = assets.audio.hiScoreMusic;
                    if (hsMusic && hsMusic.paused) hsMusic.play().catch(() => {});
                }
            }
        });

        function playHiScoreMusic() {
            stopMusic();
            if (!audioEnabled) return;
            const music = assets.audio.hiScoreMusic;
            if (music) {
                music.loop = true;
                music.volume = 0.5;
                music.play().catch(() => {});
            }
        }

        // ==========================================
        // GAME OBJECTS
        // ==========================================

        class GameObject {
            constructor(type, heightType, x) {
                this.type = type;
                this.heightType = heightType;
                this.x = x;
                this.y = this.getYPosition(heightType);
                // Drainers ~10% bigger than coins
                const sz = (type === 'drainer') ? 46 : 42;
                this.width = sz;
                this.height = sz;
                this.collected = false;
                this.pulseTime = 0;
                this.bobOffset = 0;
                this.falling = false;  // rain coins fall straight down
                this.fallSpeed = 0;
            }

            getYPosition(heightType) {
                const groundY = getGroundY();
                const playerSize = getPlayerSize();
                if (heightType === 'ground') {
                    return groundY - playerSize * 0.6;  // Coin at owl body height
                } else if (heightType === 'lower') {
                    return groundY - canvas.height * 0.2;  // Low jump
                } else {  // 'upper'
                    return groundY - canvas.height * 0.35;  // High jump
                }
            }

            update(deltaTime) {
                // Rain coins fall down AND scroll left with the background
                const dtScale = deltaTime / 16.67; // normalize to 60fps
                if (this.falling) {
                    this.y += this.fallSpeed * dtScale;
                    let speed = gameState.bgSpeed;
                    if (!gameState.grounded) speed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
                    this.x -= speed * dtScale;
                    this.pulseTime += deltaTime;
                    this.bobOffset = 0;
                    // Magnet pulls rain coins too
                    if (gameState.magnet && this.type === 'coin') {
                        const dx = gameState.playerX - this.x;
                        const dy = gameState.playerY - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 350) {
                            const pullStrength = 10 + (350 - distance) * 0.03;
                            this.x += (dx / distance) * pullStrength;
                            this.y += (dy / distance) * pullStrength;
                        }
                    }
                    return;
                }

                let speed = gameState.bgSpeed;

                // Jump moves forward - objects scroll faster when in air
                if (!gameState.grounded) {
                    speed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
                }

                this.x -= speed * dtScale;
                this.pulseTime += deltaTime;

                // Powerups float gently, coins and drainers stay still
                if (this.type !== 'drainer' && this.type !== 'coin') {
                    this.bobOffset = Math.sin(this.pulseTime / 400) * 5;
                } else {
                    this.bobOffset = 0;
                }

                // Magnet pull - only affects coins, not drainers
                // Magnet pull â€” stronger, wider range
                if (gameState.magnet && this.type === 'coin') {
                    const playerX = gameState.playerX;
                    const playerY = gameState.playerY;
                    const dx = playerX - this.x;
                    const dy = playerY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 350) {
                        const pullStrength = 10 + (350 - distance) * 0.03;
                        this.x += (dx / distance) * pullStrength;
                        this.y += (dy / distance) * pullStrength;
                    }
                }

                // (all drainers same size now)
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                const drawX = this.x;
                const drawY = this.y - this.height / 2 + this.bobOffset;

                // Draw based on type (no shadowBlur for performance)
                switch (this.type) {
                    case 'coin':
                        if (assets.images.coinSprite.complete) {
                            // Magnet trail effect
                            if (gameState.magnet) {
                                ctx.globalAlpha = 0.15;
                                ctx.drawImage(assets.images.coinSprite, drawX - this.width/2 + 16, drawY, this.width, this.height);
                                ctx.globalAlpha = 0.3;
                                ctx.drawImage(assets.images.coinSprite, drawX - this.width/2 + 8, drawY, this.width, this.height);
                                ctx.globalAlpha = 1;
                            }
                            ctx.drawImage(assets.images.coinSprite, drawX - this.width/2, drawY, this.width, this.height);
                        }
                        break;
                    case 'drainer':
                        // Big drainers use drainer2 sprite
                        if (assets.images.drainer.complete) {
                            ctx.drawImage(assets.images.drainer, drawX - this.width/2, drawY, this.width, this.height);
                        }
                        break;
                    case 'extraLife':
                    case 'shield':
                    case 'magnet':
                    case 'coinRain':
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffffff';
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        const emojiMap = { extraLife: 'â¤ï¸', shield: 'ðŸ›¡ï¸', magnet: 'ðŸ§²', coinRain: 'ðŸŒ§ï¸' };
                        ctx.fillText(emojiMap[this.type], drawX, drawY + this.height/2 + 12);
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        break;
                }

                ctx.restore();
            }

            isOffScreen() {
                if (this.falling) {
                    return this.x < -this.width || this.y > canvas.height * PHYSICS.GAME_AREA_RATIO;
                }
                return this.x < -this.width;
            }

            // Bounding box collision detection
            collidesWith(x, y, width, height) {
                // Tighter hitbox â€” 65% of visual size for precise feel
                const margin = this.width * 0.175;
                const objLeft = this.x - this.width / 2 + margin;
                const objRight = this.x + this.width / 2 - margin;
                const objTop = this.y - this.height / 2 + margin + this.bobOffset;
                const objBottom = this.y + this.height / 2 - margin + this.bobOffset;

                const playerLeft = x;
                const playerRight = x + width;
                const playerTop = y;
                const playerBottom = y + height;

                return objLeft < playerRight &&
                       objRight > playerLeft &&
                       objTop < playerBottom &&
                       objBottom > playerTop;
            }
        }


        // ==========================================
        // GAME LOGIC
        // ==========================================

        function resetGame() {
            gameState.score = 0;
            gameState.coinsCollected = 0;
            gameState.lives = 3;
            gameState.combo = 0;
            gameState.comboMultiplier = 1;
            gameState.shieldCount = 0;
            gameState.invincibleTimer = 0;
            gameState.coinRainTimer = 0;
            gameState.magnet = false;
            gameState.magnetTimer = 0;
            gameState.speedBoost = false;
            gameState.speedBoostTimer = 0;
            gameState.bgScroll = 0;
            gameState.bgSpeed = 0;
            gameState.walkSpeedBonus = 0;
            gameState.playerY = getGroundY();
            gameState.playerVelocityY = 0;
            gameState.playerX = canvas.width * PHYSICS.PLAYER_X_RATIO;
            gameState.grounded = true;
            gameState.isHolding = false;
            gameState.isWalking = false;
            gameState.objects = [];
            gameState.floatingTexts = [];
            gameState.particles = [];
            gameState.screenShake = 0;
            gameState.lastSpawnTime = 0;
            gameState.spawnInterval = 400;
            gameState.gameTime = 0;
            gameState.drainersEnabled = false;
            gameState.milestoneReached = 0;
            gameState.lastDrainerX = -1000;
            gameState.newHighScoreIndex = -1;
            gameState.compromiseMessage = '';
            gameState.compromiseMessageLife = 0;
            gameState.closeCallMessage = '';
            gameState.closeCallLife = 0;
            gameState.milestoneFlash = 0;
            gameState.lastMilestone = 0;
        }

        function spawnObject() {
            // Delay first spawn so audio has time to warm up
            if (gameState.gameTime < 1500) return;
            const now = Date.now();
            if (now - gameState.lastSpawnTime < gameState.spawnInterval) return;

            gameState.lastSpawnTime = now;

            // Coin rain mode: spawn extra coins
            const spawnCount = gameState.coinRainTimer > 0 ? 4 : 2;  // 2 base, 4 during rain

            for (let s = 0; s < spawnCount; s++) {
                // THREE Y positions: ground, lower air, upper air
                const rand = Math.random();
                const heightType = rand < 0.35 ? 'ground' : (rand < 0.7 ? 'lower' : 'upper');

                let type = 'coin';

                // Only first spawn per tick can be drainer/powerup (rest are coins)
                if (s === 0) {
                    // Drainer logic - 5% for first 15 coins, then ramps 15%â†’35% over ~90s
                    const gameTimeSec = gameState.gameTime / 1000;
                    if (gameState.drainersEnabled) {
                        const drainerProb = gameState.coinsCollected < 15
                            ? 0.05
                            : Math.min(0.35, 0.15 + (gameTimeSec / 90) * 0.20);
                        if (Math.random() < drainerProb) {
                            type = 'drainer';
                        }
                    }

                    // Powerup logic - more frequent now
                    const powerupChance = Math.min(0.18, 0.08 + gameTimeSec / 400);
                    if (type === 'coin' && Math.random() < powerupChance) {
                        const r = Math.random();
                        if (r < 0.35) type = 'shield';
                        else if (r < 0.7) type = 'magnet';
                        else type = 'coinRain';
                    }

                    // Extra life â€” very rare, only when damaged
                    if (type === 'coin' && Math.random() < 0.008 && gameState.lives < 3) {
                        type = 'extraLife';
                    }
                }

                // Check for overlap with existing objects near spawn point
                const xOffset = canvas.width + 100 + s * 80;  // stagger spawns
                const newObj = new GameObject(type, heightType, xOffset);

                const overlaps = gameState.objects.some(obj =>
                    Math.abs(obj.x - newObj.x) < 50 && Math.abs(obj.y - newObj.y) < 50
                );
                if (!overlaps && gameState.objects.length < 25) {
                    gameState.objects.push(newObj);
                }
            }

            // Coin rain: dense shower from top-right, angled toward player
            if (gameState.coinRainTimer > 0) {
                const rainCount = 4;  // 4 rain coins per spawn tick
                for (let r = 0; r < rainCount; r++) {
                    const rainCoin = new GameObject('coin', 'upper', 0);
                    // Spawn off-screen right so player runs into the rain
                    rainCoin.x = canvas.width * 0.8 + Math.random() * canvas.width * 0.4;
                    rainCoin.y = -20 - Math.random() * 100;
                    rainCoin.falling = true;
                    rainCoin.fallSpeed = 8 + Math.random() * 5;  // fast rain
                    if (gameState.objects.length < 35) {
                        gameState.objects.push(rainCoin);
                    }
                }
            }
        }

        // CRITICAL: New control system - HOLD to walk, RELEASE to jump
        function startHolding() {
            gameState.isHolding = true;

            // If grounded, immediately start walking
            if (gameState.grounded) {
                gameState.isWalking = true;
                gameState.bgSpeed = 6.5 + (gameState.walkSpeedBonus || 0);  // Faster base speed
            }
        }

        function releaseHolding() {
            gameState.isHolding = false;
            gameState.isWalking = false;

            // RELEASE = JUMP (only if grounded)
            if (gameState.grounded) {
                gameState.playerVelocityY = PHYSICS.JUMP_FORCE;
                gameState.grounded = false;
                // Keep moving during jump â€” maintain walk speed (jump multiplier handled in object update)
                gameState.bgSpeed = 6.5 + (gameState.walkSpeedBonus || 0);

                // Play jump sound ONLY when jump actually happens
                playSound('jump');
            } else {
                // Released while in air â€” stop when landing
                gameState.bgSpeed = 0;
            }
        }

        function updatePhysics(deltaTime) {
            // Apply gravity
            gameState.playerVelocityY += PHYSICS.GRAVITY;

            // Update position
            gameState.playerY += gameState.playerVelocityY;

            // Ground collision
            const groundY = getGroundY();
            if (gameState.playerY >= groundY) {
                gameState.playerY = groundY;
                gameState.playerVelocityY = 0;
                gameState.grounded = true;

                // If player is still holding when landing, start walking again
                if (gameState.isHolding) {
                    gameState.isWalking = true;
                    gameState.bgSpeed = 6.5 + (gameState.walkSpeedBonus || 0);  // Faster base speed
                } else {
                    // Idle bounce - no walking
                    gameState.isWalking = false;
                    gameState.bgSpeed = 0;
                }
            }

            // Don't go above screen
            if (gameState.playerY < 50) {
                gameState.playerY = 50;
                gameState.playerVelocityY = 0;
            }

            // Background scrolling â€” faster during jump (normalized to 60fps)
            const bgDtScale = deltaTime / 16.67;
            let scrollSpeed = gameState.bgSpeed;
            if (!gameState.grounded && scrollSpeed > 0) {
                scrollSpeed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
            }
            gameState.bgScroll += scrollSpeed * bgDtScale;
        }

        function updateGameSpeed(deltaTime) {
            gameState.gameTime += deltaTime;

            // Increase difficulty every 15 seconds (smoother ramp)
            if (Math.floor(gameState.gameTime / 15000) > Math.floor((gameState.gameTime - deltaTime) / 15000)) {
                gameState.walkSpeedBonus = (gameState.walkSpeedBonus || 0) + 0.3;
                gameState.spawnInterval = Math.max(300, gameState.spawnInterval - 30);
            }
            // Apply walk speed bonus when walking
            if (gameState.isWalking) {
                gameState.bgSpeed = 6.5 + (gameState.walkSpeedBonus || 0);  // Faster base speed
            }

            // Drainers enabled from the start
            gameState.drainersEnabled = true;

            // Visual milestones
            if (gameState.score >= 200 && gameState.milestoneReached < 3) {
                gameState.milestoneReached = 3;
            } else if (gameState.score >= 100 && gameState.milestoneReached < 2) {
                gameState.milestoneReached = 2;
            } else if (gameState.score >= 50 && gameState.milestoneReached < 1) {
                gameState.milestoneReached = 1;
            }

            // Update compromise message timer
            if (gameState.compromiseMessageLife > 0) {
                gameState.compromiseMessageLife -= deltaTime;
            }

            // Update invincibility timer
            if (gameState.invincibleTimer > 0) {
                gameState.invincibleTimer -= deltaTime;
            }

            // Update coin rain timer
            if (gameState.coinRainTimer > 0) {
                gameState.coinRainTimer -= deltaTime;
            }
        }

        function checkCollisions() {
            const playerX = gameState.playerX;
            const playerY = gameState.playerY;
            const playerSize = getPlayerSize();

            gameState.objects.forEach((obj, index) => {
                if (obj.collected) return;

                // Position-based bounding box collision - playerY is at feet, sprite extends upward
                // Tighter player hitbox â€” 70% of sprite
                const hitMargin = playerSize * 0.15;
                if (obj.collidesWith(playerX - playerSize/2 + hitMargin, playerY - playerSize + hitMargin, playerSize - hitMargin*2, playerSize - hitMargin*2)) {
                    obj.collected = true;

                    switch (obj.type) {
                        case 'coin':
                            gameState.score += 1;
                            gameState.coinsCollected++;

                            playSound('coin');
                            break;

                        case 'drainer':
                            if (gameState.invincibleTimer > 0) {
                                // i-frames active, ignore hit
                                obj.collected = false;  // don't consume the drainer
                                return;
                            }
                            if (gameState.shieldCount > 0) {
                                gameState.shieldCount--;
                                playSound('shieldBlock');
                            } else {
                                // Lose a life
                                gameState.lives--;
                                gameState.invincibleTimer = 1500;  // 1.5s i-frames after taking damage
                                gameState.combo = 0;
                                gameState.comboMultiplier = 1;
                                gameState.screenShake = 15;
                                playSound('drain');

                                // Random compromise message
                                const messages = [
                                    'Wallet compromised!',
                                    'Seed phrase leaked!',
                                    'Connected to malicious dApp!',
                                    'Approved unlimited spend!',
                                    'Phishing link clicked!',
                                    'Rug pull detected!',
                                    'Private key exposed!',
                                    'Smart contract exploit!'
                                ];
                                gameState.compromiseMessage = messages[Math.floor(Math.random() * messages.length)];
                                gameState.compromiseMessageLife = 1500;  // Show for 1.5 seconds

                                // Check for game over
                                if (gameState.lives <= 0) {
                                    currentState = GAME_STATE.GAME_OVER; stopMusic(); playHiScoreMusic();
                                }
                            }
                            break;

                        case 'shield':
                            gameState.shieldCount = Math.min(gameState.shieldCount + 1, 2);
                            playSound('coin');
                            break;

                        case 'magnet':
                            gameState.magnet = true;
                            gameState.magnetTimer = 4000;
                            playSound('coin');
                            break;

                        case 'coinRain':
                            gameState.coinRainTimer = 5000;  // 5 seconds of coin rain
                            playSound('coin');
                            break;

                        case 'extraLife':
                            gameState.lives = Math.min(3, gameState.lives + 1);
                            playSound('money');
                            gameState.milestoneFlash = 200;
                            break;
                    }
                }

                // (close call removed)
            });

            // Remove collected and off-screen objects
            gameState.objects = gameState.objects.filter(obj => !obj.collected && !obj.isOffScreen());

            // Missed coin tracking (combo removed)
            gameState.objects.forEach(obj => {
                if (false) { // combo removed
                }
            });
        }


        // ==========================================
        // DRAWING FUNCTIONS
        // ==========================================

        function drawBackground() {
            ctx.save();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // Background tint based on milestone
            let tint = '#1a0033';
            if (gameState.milestoneReached >= 3) {
                tint = '#330066';
            } else if (gameState.milestoneReached >= 2) {
                tint = '#220044';
            } else if (gameState.milestoneReached >= 1) {
                tint = '#1a0040';
            }

            ctx.fillStyle = tint;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw scrolling background in top 80% (game area)
            if (assets.images.background.complete) {
                const gameAreaHeight = canvas.height * PHYSICS.GAME_AREA_RATIO;
                const bgOffsetY = 0;
                const bgHeight = gameAreaHeight;
                const bgWidth = assets.images.background.width * (bgHeight / assets.images.background.height);
                const scrollX = -gameState.bgScroll % bgWidth;

                ctx.globalAlpha = 0.7;
                ctx.drawImage(assets.images.background, scrollX, bgOffsetY, bgWidth, bgHeight);
                ctx.drawImage(assets.images.background, scrollX + bgWidth, bgOffsetY, bgWidth, bgHeight);
                ctx.globalAlpha = 1.0;
            }

            // Draw hold zone at bottom 20%
            const holdZoneY = canvas.height * PHYSICS.GAME_AREA_RATIO;
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, holdZoneY, canvas.width, canvas.height * PHYSICS.HOLD_ZONE_RATIO);

            // Hold zone text â€” yellow for visibility
            ctx.fillStyle = '#ffff00';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.isHolding ? 'RELEASE TO JUMP' : 'HOLD TO RUN', canvas.width / 2, holdZoneY + canvas.height * PHYSICS.HOLD_ZONE_RATIO / 2);

            // Quit button â€” bottom left
            const quitW = 50;
            const quitH = 20;
            const quitX = 8;
            const quitY = canvas.height - quitH - 4;
            ctx.fillStyle = 'rgba(80,0,0,0.6)';
            ctx.fillRect(quitX, quitY, quitW, quitH);
            ctx.strokeStyle = '#f44';
            ctx.lineWidth = 1;
            ctx.strokeRect(quitX, quitY, quitW, quitH);
            ctx.fillStyle = '#f88';
            ctx.font = '7px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('QUIT', quitX + quitW/2, quitY + 14);

            ctx.restore();
        }

        function drawPlayer() {
            // Invincibility flashing â€” skip drawing every other 100ms
            if (gameState.invincibleTimer > 0) {
                if (Math.floor(gameState.invincibleTimer / 100) % 2 === 0) {
                    return;  // invisible frame â€” creates flashing effect
                }
            }

            const playerX = gameState.playerX;
            const playerY = gameState.playerY;
            const playerSize = getPlayerSize();

            ctx.save();
            // Always reset shadow first â€” no glow by default
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            const owlCenterY = playerY - playerSize / 2;

            // Shield ring + yellow glow (double ring at 2 stacks)
            if (gameState.shieldCount > 0) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(playerX, owlCenterY, playerSize/2 + 5, 0, Math.PI * 2);
                ctx.stroke();
                if (gameState.shieldCount >= 2) {
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(playerX, owlCenterY, playerSize/2 + 12, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Magnet red glow (no ring)
            if (gameState.magnet) {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0000';
            }

            // Draw player sprite - glow carries over from powerup if active
            const frameIndex = Math.floor(gameState.playerAnimFrame) % 6 + 1;
            let spriteImg;

            if (gameState.isWalking) {
                spriteImg = assets.images[`walk${frameIndex}`];
            } else {
                spriteImg = assets.images[`jump${frameIndex}`];
            }

            if (spriteImg && spriteImg.complete) {
                ctx.drawImage(spriteImg, playerX - playerSize/2, playerY - playerSize, playerSize, playerSize);
            } else {
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(playerX, playerY, playerSize/2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Kill shadow state completely
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.restore();
        }

        function drawUI() {
            ctx.save();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#0ff';
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'left';

            // Score â€” aligned with bottom of life icons
            ctx.fillText(`SCORE: ${gameState.score}`, 15, 42);

            // (combo display removed)

            // (close call display removed)

            // Coin rain â€” handled in spawnObject, no extra visual needed here

            // Lives display - owl faces on same line as score, top right
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            const livesX = canvas.width - 10;  // Right edge
            const livesY = 8;  // Lowered for taller moonbird sprites
            const lifeSize = 55;
            const lifeSpacing = 55;
            const owlLifeImg = assets.images.look1;

            for (let i = 0; i < gameState.lives; i++) {
                const lx = livesX - (i * lifeSpacing) - lifeSize;
                const ly = livesY;
                if (owlLifeImg && owlLifeImg.complete) {
                    const sw = owlLifeImg.naturalWidth;
                    const sh = owlLifeImg.naturalHeight;
                    const cropX = sw * 0.05;
                    const cropY = 0;
                    const cropW = sw * 0.9;
                    const cropH = sh * 0.58;
                    const drawH = lifeSize * (cropH / cropW);
                    ctx.drawImage(owlLifeImg, cropX, cropY, cropW, cropH, lx, ly, lifeSize, drawH);
                }
            }

            // Compromise message - big banner style
            if (gameState.compromiseMessageLife > 0) {
                const alpha = Math.min(1, gameState.compromiseMessageLife / 500);  // Fade out
                ctx.save();
                ctx.globalAlpha = alpha;

                // Semi-transparent black background banner
                const bannerY = canvas.height * 0.3;
                const bannerHeight = 50;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, bannerY - bannerHeight/2, canvas.width, bannerHeight);

                // Red border on banner
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, bannerY - bannerHeight/2, canvas.width, bannerHeight);

                // White text â€” auto-size to fit screen width
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                let fontSize = 16;
                ctx.font = `${fontSize}px "Press Start 2P"`;
                while (ctx.measureText(gameState.compromiseMessage).width > canvas.width - 20 && fontSize > 8) {
                    fontSize -= 1;
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                }
                ctx.fillText(gameState.compromiseMessage, canvas.width / 2, bannerY + fontSize/2);

                ctx.restore();
            }

            ctx.restore();
        }

        function drawTitleScreen() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw title image
            if (assets.images.title.complete) {
                ctx.drawImage(assets.images.title, 0, 0, canvas.width, canvas.height);
            }

            // Animated owl sprite (look_1 through look_6)
            const lookFrames = [assets.images.look1, assets.images.look2, assets.images.look3, assets.images.look4, assets.images.look5, assets.images.look6];
            const frameIdx = Math.floor(Date.now() / 130) % 6;
            const owlFrame = lookFrames[frameIdx];
            if (owlFrame && owlFrame.complete) {
                const owlSize = canvas.width * 0.45;
                const owlX = canvas.width / 2 - owlSize / 2;
                const owlY = canvas.height * 0.42;
                ctx.drawImage(owlFrame, owlX, owlY, owlSize, owlSize);
            }

            // Tap to start below owl â€” only show when audio is ready
            ctx.font = '18px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#0ff';
            const pulseA = 0.5 + 0.5 * Math.sin(Date.now() / 300);
            ctx.globalAlpha = pulseA;
            ctx.fillText('TAP TO START', canvas.width / 2, canvas.height * 0.72);
            ctx.globalAlpha = 1;

            // Choose Bird button (centered, below TAP TO START)
            ctx.font = '14px "Press Start 2P"';
            ctx.fillStyle = '#ffd700';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 6;
            ctx.fillText('CHOOSE BIRD', canvas.width / 2, canvas.height * 0.85);
            ctx.font = '10px "Press Start 2P"';
            ctx.fillStyle = '#888';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillText(`[${getMoonbirdDisplayName()}]`, canvas.width / 2, canvas.height * 0.875);

            // How to play button (left side of bottom)
            ctx.fillStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('HOW TO PLAY', canvas.width * 0.25, canvas.height * 0.95);

            // High scores button (right side of bottom)
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.fillText('HIGH SCORES', canvas.width * 0.75, canvas.height * 0.95);
        }

        // Helper: start game, loading moonbird sprites first if needed
        function startGameWithBird() {
            loadMoonbirdGameSprites(moonbirdState.selectedId).then(() => {
                resetGame();
                currentState = GAME_STATE.PLAYING;
                stopMusic();
                startMusic();
            });
        }

        // Naming overlay state
        let namingOverlay = null; // {slotIdx, text, reservedMsg}

        function drawChooseBird() {
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const ch = canvas.height;
            const cw = canvas.width;
            // Responsive unit â€” everything scales from this
            const u = Math.min(ch / 100, cw / 50);
            const font = (sz) => `${Math.round(sz * u)}px "Press Start 2P"`;
            const gap = Math.round(u * 1.2);

            ctx.textAlign = 'center';
            // First pass: calculate total height, then offset to vertically center
            const previewSizeCalc = Math.min(cw * 0.28, ch * 0.18);
            const padBtnHCalc = Math.round(u * 5.5);
            const padGapCalc = Math.round(u * 1);
            const gapCalc = Math.round(u * 1.2);
            const actBtnHCalc = Math.round(u * 5.5);
            const slotHCalc = Math.round(u * 7);
            const saveBtnHCalc = Math.round(u * 4.5);
            const inputBoxHCalc = u * 6;
            // Title height + gap + preview + gap + name + gap + input + gap + numpad (4 rows) + gap + action row + gap + slots + gap + save btn + gap + bottom row
            const totalH = u * 3           // title text
                + u * 2                     // gap after title
                + previewSizeCalc           // bird preview
                + u * 4                     // gap after preview
                + u * 2                     // name label
                + u * 2                     // gap after name
                + inputBoxHCalc             // input box
                + gapCalc                   // gap
                + 4 * (padBtnHCalc + padGapCalc) // numpad
                + gapCalc                   // gap
                + actBtnHCalc               // random/miscreant row
                + gapCalc * 1.5             // gap
                + slotHCalc                 // slots
                + gapCalc                   // gap
                + saveBtnHCalc              // save button
                + gapCalc                   // gap
                + actBtnHCalc;              // back/play row
            const yOffset = Math.max(0, (ch - totalH) / 2);
            ctx.save();
            ctx.translate(0, yOffset);
            // Store offset for click handler
            moonbirdState._yOffset = yOffset;
            let yPos = 0;

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = font(3);
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ffd700';
            ctx.fillText('CHOOSE YOUR BIRD', cx, yPos);
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            yPos += u * 2;

            // Preview area
            const previewSize = Math.min(cw * 0.28, ch * 0.18);
            const previewX = cx - previewSize / 2;
            const previewY = yPos;

            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(previewX - 3, previewY - 3, previewSize + 6, previewSize + 6);

            if (moonbirdState.previewLoading) {
                ctx.fillStyle = '#0ff';
                let loadFont = Math.round(1.5 * u);
                ctx.font = `${loadFont}px "Press Start 2P"`;
                while (ctx.measureText('LOADING...').width > previewSize * 0.9 && loadFont > 6) {
                    loadFont--;
                    ctx.font = `${loadFont}px "Press Start 2P"`;
                }
                ctx.fillText('LOADING...', cx, previewY + previewSize / 2);
            } else if (moonbirdState.previewSprites) {
                const frameIdx = Math.floor(Date.now() / 130) % 6;
                const sprite = moonbirdState.previewSprites[`idle_${frameIdx + 1}`];
                if (sprite) ctx.drawImage(sprite, previewX, previewY, previewSize, previewSize);
            } else {
                const lookFrames = [assets.images.look1, assets.images.look2, assets.images.look3, assets.images.look4, assets.images.look5, assets.images.look6];
                const frameIdx = Math.floor(Date.now() / 130) % 6;
                const f = lookFrames[frameIdx];
                if (f && f.complete) ctx.drawImage(f, previewX, previewY, previewSize, previewSize);
            }
            yPos += previewSize + u * 4;

            // Selection label
            ctx.fillStyle = '#fff';
            const dispName = getMoonbirdDisplayName();
            let nameFont = Math.round(2 * u);
            ctx.font = `${nameFont}px "Press Start 2P"`;
            while (ctx.measureText(dispName).width > cw * 0.8 && nameFont > 6) {
                nameFont--;
                ctx.font = `${nameFont}px "Press Start 2P"`;
            }
            ctx.fillText(dispName, cx, yPos);
            yPos += u * 2;

            // Input box
            const inputBoxW = cw * 0.45;
            const inputBoxH = u * 6;
            const inputBoxX = cx - inputBoxW / 2;
            const inputBoxY = yPos;
            ctx.fillStyle = '#000';
            ctx.fillRect(inputBoxX, inputBoxY, inputBoxW, inputBoxH);
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(inputBoxX, inputBoxY, inputBoxW, inputBoxH);

            ctx.fillStyle = '#0ff';
            ctx.font = font(3);
            const displayDigits = moonbirdState.inputDigits || '____';
            ctx.fillText(displayDigits, cx, inputBoxY + inputBoxH * 0.7);
            yPos += inputBoxH + gap;

            // Numpad
            const padBtnW = Math.round(cw * 0.13);
            const padBtnH = Math.round(u * 5.5);
            const padGap = Math.round(u * 1);
            const padTotalW = padBtnW * 3 + padGap * 2;
            const padStartX = cx - padTotalW / 2;
            const padTop = yPos;

            const padButtons = [['1','2','3'],['4','5','6'],['7','8','9'],['DEL','0','GO']];

            padButtons.forEach((row, ri) => {
                row.forEach((label, ci) => {
                    const bx = padStartX + ci * (padBtnW + padGap);
                    const by = padTop + ri * (padBtnH + padGap);
                    if (label === 'DEL') ctx.fillStyle = '#f44';
                    else if (label === 'GO') ctx.fillStyle = '#0f0';
                    else ctx.fillStyle = '#333';
                    ctx.fillRect(bx, by, padBtnW, padBtnH);
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(bx, by, padBtnW, padBtnH);
                    ctx.fillStyle = '#fff';
                    const btnFont = Math.round(label.length > 1 ? padBtnH * 0.32 : padBtnH * 0.45);
                    ctx.font = `${btnFont}px "Press Start 2P"`;
                    ctx.fillText(label, bx + padBtnW/2, by + padBtnH * 0.65);
                });
            });
            yPos = padTop + 4 * (padBtnH + padGap) + gap;

            // Action row: RANDOM / MISCREANT
            const actY = yPos;
            const actBtnW = (padTotalW - padGap) / 2;
            const actBtnH = Math.round(u * 5.5);

            const actFont = `${Math.round(actBtnH * 0.32)}px "Press Start 2P"`;

            ctx.fillStyle = '#0ff';
            ctx.fillRect(padStartX, actY, actBtnW, actBtnH);
            ctx.fillStyle = '#000';
            ctx.font = actFont;
            ctx.fillText('RANDOM', padStartX + actBtnW/2, actY + actBtnH * 0.65);

            ctx.fillStyle = '#f0f';
            ctx.fillRect(padStartX + actBtnW + padGap, actY, actBtnW, actBtnH);
            ctx.fillStyle = '#000';
            let mFont = Math.round(actBtnH * 0.45);
            ctx.font = `${mFont}px "Press Start 2P"`;
            while (ctx.measureText('MISCREANT').width > actBtnW * 0.9 && mFont > 4) {
                mFont--;
                ctx.font = `${mFont}px "Press Start 2P"`;
            }
            ctx.textBaseline = 'middle';
            ctx.fillText('MISCREANT', padStartX + actBtnW + padGap + actBtnW/2, actY + actBtnH/2);
            ctx.textBaseline = 'alphabetic';
            yPos += actBtnH + gap * 1.5;

            // === SAVE SLOTS ===
            const slotY = yPos;
            const slotW = (padTotalW - padGap * 2) / 3;
            const slotH = Math.round(u * 7);

            for (let i = 0; i < 3; i++) {
                const sx = padStartX + i * (slotW + padGap);
                const slot = moonbirdState.slots[i];
                const isActive = slot && slot.id === moonbirdState.selectedId;

                ctx.fillStyle = isActive ? '#1a3a1a' : '#1a1a2e';
                ctx.fillRect(sx, slotY, slotW, slotH);
                ctx.strokeStyle = isActive ? '#0f0' : '#555';
                ctx.lineWidth = isActive ? 2 : 1;
                ctx.strokeRect(sx, slotY, slotW, slotH);

                const fitText = (text, maxW, startSize) => {
                    let fs = startSize;
                    ctx.font = `${fs}px "Press Start 2P"`;
                    while (ctx.measureText(text).width > maxW * 0.9 && fs > 4) {
                        fs--;
                        ctx.font = `${fs}px "Press Start 2P"`;
                    }
                };
                if (slot) {
                    const fullName = slot.name || `#${slot.id}`;
                    ctx.fillStyle = '#fff';
                    fitText(fullName, slotW, Math.round(slotH * 0.17));
                    ctx.fillText(fullName, sx + slotW/2, slotY + slotH * 0.35);
                    ctx.fillStyle = '#0ff';
                    fitText(`#${slot.id}`, slotW, Math.round(slotH * 0.13));
                    ctx.fillText(`#${slot.id}`, sx + slotW/2, slotY + slotH * 0.6);
                    ctx.fillStyle = '#555';
                    fitText('TAP=LOAD', slotW, Math.round(slotH * 0.1));
                    ctx.fillText('TAP=LOAD', sx + slotW/2, slotY + slotH * 0.85);
                } else {
                    ctx.fillStyle = '#888';
                    fitText(`SLOT ${i+1}`, slotW, Math.round(slotH * 0.17));
                    ctx.fillText(`SLOT ${i+1}`, sx + slotW/2, slotY + slotH * 0.4);
                    ctx.fillStyle = '#555';
                    fitText('EMPTY', slotW, Math.round(slotH * 0.13));
                    ctx.fillText('EMPTY', sx + slotW/2, slotY + slotH * 0.7);
                }
            }
            yPos += slotH + gap;

            // SAVE TO SLOT button
            const saveY = yPos;
            const saveBtnW = padTotalW;
            const saveBtnH = Math.round(u * 4.5);
            ctx.fillStyle = '#2a5a2a';
            ctx.fillRect(padStartX, saveY, saveBtnW, saveBtnH);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(padStartX, saveY, saveBtnW, saveBtnH);
            ctx.fillStyle = '#0f0';
            let saveFont = Math.round(saveBtnH * 0.35);
            ctx.font = `${saveFont}px "Press Start 2P"`;
            while (ctx.measureText('SAVE TO SLOT...').width > saveBtnW * 0.9 && saveFont > 4) {
                saveFont--;
                ctx.font = `${saveFont}px "Press Start 2P"`;
            }
            ctx.fillText('SAVE TO SLOT...', padStartX + saveBtnW/2, saveY + saveBtnH * 0.65);
            yPos += saveBtnH + gap;

            // Bottom row: BACK and PLAY
            const bottomY = yPos;

            ctx.fillStyle = '#555';
            ctx.fillRect(padStartX, bottomY, actBtnW, actBtnH);
            ctx.fillStyle = '#fff';
            ctx.font = actFont;
            ctx.fillText('< BACK', padStartX + actBtnW/2, bottomY + actBtnH * 0.65);

            ctx.fillStyle = '#ffd700';
            ctx.fillRect(padStartX + actBtnW + padGap, bottomY, actBtnW, actBtnH);
            ctx.fillStyle = '#000';
            ctx.font = `${Math.round(actBtnH * 0.38)}px "Press Start 2P"`;
            ctx.fillText('PLAY!', padStartX + actBtnW + padGap + actBtnW/2, bottomY + actBtnH * 0.65);

            // Store layout for click handler
            moonbirdState._layout = { padStartX, padTop, padBtnW, padBtnH, padGap, padTotalW, actY, actBtnW, actBtnH, slotY, slotW, slotH, saveY, saveBtnW, saveBtnH, bottomY };
            ctx.restore();

            // === NAMING OVERLAY ===
            if (namingOverlay && namingOverlay.mode === 'pickSlot') {
                // Slot picker â€” all slots full, choose which to overwrite
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, cw, ch);

                const ow = cw * 0.85;
                const ox = cx - ow/2;
                const oy = ch * 0.3;

                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(ox, oy, ow, ch * 0.3);
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(ox, oy, ow, ch * 0.3);

                ctx.fillStyle = '#ffd700';
                ctx.font = font(2);
                ctx.fillText('REPLACE WHICH SLOT?', cx, oy + u * 5);

                const psW = (ow - padGap * 4) / 3;
                const psH = u * 10;
                const psY = oy + u * 8;
                const psX = ox + padGap;

                for (let i = 0; i < 3; i++) {
                    const sx = psX + i * (psW + padGap);
                    const slot = moonbirdState.slots[i];
                    ctx.fillStyle = '#333';
                    ctx.fillRect(sx, psY, psW, psH);
                    ctx.strokeStyle = '#f80';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sx, psY, psW, psH);
                    if (slot) {
                        ctx.fillStyle = '#fff';
                        ctx.font = font(1.3);
                        ctx.fillText(slot.name || `#${slot.id}`, sx + psW/2, psY + psH * 0.4);
                        ctx.fillStyle = '#0ff';
                        ctx.font = font(1);
                        ctx.fillText(`#${slot.id}`, sx + psW/2, psY + psH * 0.65);
                    }
                }

                // Cancel button
                const pcY = psY + psH + u * 3;
                const pcW = ow * 0.4;
                const pcH = u * 5;
                ctx.fillStyle = '#f44';
                ctx.fillRect(cx - pcW/2, pcY, pcW, pcH);
                ctx.fillStyle = '#fff';
                ctx.font = font(1.8);
                ctx.fillText('CANCEL', cx, pcY + pcH * 0.65);

                namingOverlay._pickLayout = { psX, psY, psW, psH, pcY, pcW, pcH };

            } else if (namingOverlay && namingOverlay.mode === 'name') {
                // Name entry overlay
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, cw, ch);

                const ow = cw * 0.9;
                const oh = ch * 0.55;
                const ox = cx - ow/2;
                const oy = ch * 0.22;

                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(ox, oy, ow, oh);
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(ox, oy, ow, oh);

                ctx.fillStyle = '#ffd700';
                ctx.font = font(2.2);
                ctx.fillText('NAME YOUR BIRD', cx, oy + u * 6);
                ctx.fillStyle = '#888';
                ctx.font = font(1.5);
                ctx.fillText(`SLOT ${namingOverlay.slotIdx + 1} â€” #${moonbirdState.selectedId}`, cx, oy + u * 10);

                const niY = oy + u * 13;
                const niW = ow * 0.8;
                const niX = cx - niW/2;
                const niH = u * 6;
                ctx.fillStyle = '#000';
                ctx.fillRect(niX, niY, niW, niH);
                ctx.strokeStyle = '#0ff';
                ctx.strokeRect(niX, niY, niW, niH);
                ctx.fillStyle = '#0ff';
                ctx.font = font(2.2);
                ctx.fillText(namingOverlay.text || '', cx, niY + niH * 0.7);

                if (namingOverlay.reservedMsg) {
                    ctx.fillStyle = '#f44';
                    ctx.font = font(1.3);
                    ctx.fillText(namingOverlay.reservedMsg, cx, niY + niH + u * 3);
                }

                const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_ <';
                const cols = 7;
                const lbW = Math.floor((ow * 0.88) / cols);
                const lbH = Math.round(u * 4.5);
                const lbGap = Math.round(u * 0.5);
                const lgX = cx - (cols * (lbW + lbGap) - lbGap) / 2;
                const lgY = niY + niH + u * 5;

                for (let i = 0; i < letters.length; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const lx = lgX + col * (lbW + lbGap);
                    const ly = lgY + row * (lbH + lbGap);
                    const ch2 = letters[i];
                    ctx.fillStyle = ch2 === '<' ? '#f44' : ch2 === '_' ? '#555' : '#333';
                    ctx.fillRect(lx, ly, lbW, lbH);
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(lx, ly, lbW, lbH);
                    ctx.fillStyle = '#fff';
                    ctx.font = font(1.8);
                    const display = ch2 === '_' ? 'SPC' : ch2 === '<' ? 'DEL' : ch2;
                    ctx.fillText(display, lx + lbW/2, ly + lbH * 0.65);
                }

                const obY = lgY + Math.ceil(letters.length / cols) * (lbH + lbGap) + u * 2;
                const obW = ow * 0.35;
                const obH = Math.round(u * 5.5);

                ctx.fillStyle = '#0f0';
                ctx.fillRect(cx - obW - 5, obY, obW, obH);
                ctx.fillStyle = '#000';
                ctx.font = font(2);
                ctx.fillText('SAVE', cx - obW/2 - 5, obY + obH * 0.65);

                ctx.fillStyle = '#f44';
                ctx.fillRect(cx + 5, obY, obW, obH);
                ctx.fillStyle = '#fff';
                ctx.fillText('CANCEL', cx + obW/2 + 5, obY + obH * 0.65);

                namingOverlay._layout = { ox, oy, ow, oh, niX, niY, niW, lgX, lgY, lbW, lbH, lbGap, cols, letters, obY, obW, obH };
            }
        }

        function handleChooseBirdClick(x, y) {
            // Handle naming overlay first (draws at absolute coords, no offset)
            if (namingOverlay) {
                handleNamingClick(x, y);
                return;
            }

            // Adjust for vertical centering offset (only for chooser buttons)
            y -= (moonbirdState._yOffset || 0);

            const L = moonbirdState._layout;
            if (!L) return;
            const { padStartX, padTop, padBtnW, padBtnH, padGap, padTotalW, actY, actBtnW, actBtnH, slotY, slotW, slotH, saveY, saveBtnW, saveBtnH, bottomY } = L;

            // Numpad
            const padButtons = [['1','2','3'],['4','5','6'],['7','8','9'],['DEL','0','GO']];
            for (let ri = 0; ri < padButtons.length; ri++) {
                for (let ci = 0; ci < padButtons[ri].length; ci++) {
                    const bx = padStartX + ci * (padBtnW + padGap);
                    const by = padTop + ri * (padBtnH + padGap);
                    if (x > bx && x < bx + padBtnW && y > by && y < by + padBtnH) {
                        const label = padButtons[ri][ci];
                        if (label === 'DEL') {
                            moonbirdState.inputDigits = moonbirdState.inputDigits.slice(0, -1);
                            moonbirdState.inputFresh = false;
                        } else if (label === 'GO') {
                            const num = parseInt(moonbirdState.inputDigits);
                            if (!isNaN(num) && num >= 0 && num <= 9999) {
                                moonbirdState.selectedId = num;
                                moonbirdState.inputFresh = true;
                                saveMoonbirdSelection();
                                loadMoonbirdPreview(num);
                            }
                        } else {
                            if (moonbirdState.inputFresh) {
                                moonbirdState.inputDigits = label;
                                moonbirdState.inputFresh = false;
                            } else if (moonbirdState.inputDigits.length < 4) {
                                moonbirdState.inputDigits += label;
                            }
                        }
                        return;
                    }
                }
            }

            // RANDOM button
            if (x > padStartX && x < padStartX + actBtnW && y > actY && y < actY + actBtnH) {
                const randomId = Math.floor(Math.random() * 10000);
                moonbirdState.inputDigits = randomId.toString();
                moonbirdState.inputFresh = true;
                moonbirdState.selectedId = randomId;
                saveMoonbirdSelection();
                loadMoonbirdPreview(randomId);
                return;
            }

            // MISCREANT button
            if (x > padStartX + actBtnW + padGap && x < padStartX + padTotalW && y > actY && y < actY + actBtnH) {
                moonbirdState.selectedId = MISCREANT_BIRD_ID;
                moonbirdState.inputDigits = MISCREANT_BIRD_ID.toString();
                moonbirdState.inputFresh = true;
                saveMoonbirdSelection();
                loadMoonbirdPreview(MISCREANT_BIRD_ID);
                return;
            }

            // Save slots â€” tap to load
            for (let i = 0; i < 3; i++) {
                const sx = padStartX + i * (slotW + padGap);
                if (x > sx && x < sx + slotW && y > slotY && y < slotY + slotH) {
                    const slot = moonbirdState.slots[i];
                    if (slot) {
                        moonbirdState.selectedId = slot.id;
                        moonbirdState.inputDigits = slot.id.toString();
                        moonbirdState.inputFresh = true;
                        saveMoonbirdSelection();
                        loadMoonbirdPreview(slot.id);
                    }
                    return;
                }
            }

            // SAVE TO SLOT button
            if (x > padStartX && x < padStartX + saveBtnW && y > saveY && y < saveY + saveBtnH) {
                const birdId = moonbirdState.selectedId;
                const reservedName = RESERVED_NAMES[birdId];
                
                // Check if this bird is already saved in a slot
                const existingSlot = moonbirdState.slots.findIndex(s => s && s.id === birdId);
                if (existingSlot !== -1) return; // already saved, don't duplicate

                // Find first empty slot
                let slotIdx = moonbirdState.slots.findIndex(s => s === null);
                
                if (slotIdx === -1) {
                    // All slots full â€” enter slot-pick mode
                    namingOverlay = { mode: 'pickSlot', text: reservedName || '', reservedMsg: null };
                    return;
                }

                // Reserved/easter egg birds auto-save with their locked name
                if (reservedName) {
                    moonbirdState.slots[slotIdx] = { id: birdId, name: reservedName };
                    saveMoonbirdSlots();
                    return;
                }

                // Normal bird â€” open naming overlay
                namingOverlay = { mode: 'name', slotIdx, text: '', reservedMsg: null };
                return;
            }

            // BACK button â€” reload game sprites so title screen shows selected bird
            if (x > padStartX && x < padStartX + actBtnW && y > bottomY && y < bottomY + actBtnH) {
                loadMoonbirdGameSprites(moonbirdState.selectedId).then(() => {
                    currentState = GAME_STATE.TITLE;
                });
                return;
            }

            // PLAY button
            if (x > padStartX + actBtnW + padGap && x < padStartX + padTotalW && y > bottomY && y < bottomY + actBtnH) {
                startGameWithBird();
                return;
            }
        }

        function handleNamingClick(x, y) {
            const cx = canvas.width / 2;

            // === PICK SLOT MODE ===
            if (namingOverlay.mode === 'pickSlot') {
                const P = namingOverlay._pickLayout;
                if (!P) return;
                const { psX, psY, psW, psH, pcY, pcW, pcH } = P;

                // Check slot clicks
                for (let i = 0; i < 3; i++) {
                    const sx = psX + i * (psW + moonbirdState._layout.padGap);
                    if (x > sx && x < sx + psW && y > psY && y < psY + psH) {
                        const birdId = moonbirdState.selectedId;
                        const reservedName = RESERVED_NAMES[birdId];
                        if (reservedName) {
                            // Reserved bird â€” auto-save
                            moonbirdState.slots[i] = { id: birdId, name: reservedName };
                            saveMoonbirdSlots();
                            namingOverlay = null;
                        } else {
                            // Normal bird â€” switch to naming mode for this slot
                            namingOverlay = { mode: 'name', slotIdx: i, text: '', reservedMsg: null };
                        }
                        return;
                    }
                }

                // Cancel
                if (x > cx - pcW/2 && x < cx + pcW/2 && y > pcY && y < pcY + pcH) {
                    namingOverlay = null;
                    return;
                }
                return;
            }

            // === NAME MODE ===
            const L = namingOverlay._layout;
            if (!L) return;
            const { lgX, lgY, lbW, lbH, lbGap, cols, letters, obY, obW, obH } = L;

            // Letter grid
            for (let i = 0; i < letters.length; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const lx = lgX + col * (lbW + lbGap);
                const ly = lgY + row * (lbH + lbGap);
                if (x > lx && x < lx + lbW && y > ly && y < ly + lbH) {
                    const ch = letters[i];
                    if (ch === '<') {
                        namingOverlay.text = namingOverlay.text.slice(0, -1);
                    } else if (ch === '_') {
                        if (namingOverlay.text.length < 12) namingOverlay.text += ' ';
                    } else {
                        if (namingOverlay.text.length < 12) namingOverlay.text += ch;
                    }
                    namingOverlay.reservedMsg = null;
                    return;
                }
            }

            // SAVE button
            if (x > cx - obW - 5 && x < cx - 5 && y > obY && y < obY + obH) {
                const name = namingOverlay.text.trim().toUpperCase();
                if (!name) {
                    namingOverlay.reservedMsg = 'ENTER A NAME';
                    return;
                }
                if (isReservedName(name)) {
                    namingOverlay.reservedMsg = 'NAME RESERVED!';
                    return;
                }
                moonbirdState.slots[namingOverlay.slotIdx] = { id: moonbirdState.selectedId, name };
                saveMoonbirdSlots();
                namingOverlay = null;
                return;
            }

            // CANCEL button
            if (x > cx + 5 && x < cx + obW + 5 && y > obY && y < obY + obH) {
                namingOverlay = null;
                return;
            }
        }

        // Handle keyboard input for the chooser screen
        document.addEventListener('keydown', (e) => {
            if (currentState !== GAME_STATE.CHOOSE_BIRD) return;

            // Naming overlay keyboard
            if (namingOverlay) {
                if (e.key === 'Escape') { namingOverlay = null; return; }
                if (e.key === 'Backspace') { namingOverlay.text = namingOverlay.text.slice(0, -1); return; }
                if (e.key === 'Enter') {
                    const name = namingOverlay.text.trim().toUpperCase();
                    if (name && !isReservedName(name)) {
                        moonbirdState.slots[namingOverlay.slotIdx] = { id: moonbirdState.selectedId, name };
                        saveMoonbirdSlots();
                        namingOverlay = null;
                    }
                    return;
                }
                if (/^[a-zA-Z ]$/.test(e.key) && namingOverlay.text.length < 12) {
                    namingOverlay.text += e.key.toUpperCase();
                    namingOverlay.reservedMsg = null;
                }
                return;
            }
            
            // Number input
            if (e.key >= '0' && e.key <= '9') {
                if (moonbirdState.inputFresh) {
                    moonbirdState.inputDigits = e.key;
                    moonbirdState.inputFresh = false;
                } else if (moonbirdState.inputDigits.length < 4) {
                    moonbirdState.inputDigits += e.key;
                }
            } else if (e.key === 'Backspace') {
                moonbirdState.inputDigits = moonbirdState.inputDigits.slice(0, -1);
                moonbirdState.inputFresh = false;
            } else if (e.key === 'Enter') {
                const num = parseInt(moonbirdState.inputDigits);
                if (!isNaN(num) && num >= 0 && num <= 9999) {
                    moonbirdState.selectedId = num;
                    moonbirdState.inputFresh = true;
                    saveMoonbirdSelection();
                    loadMoonbirdPreview(num);
                }
            } else if (e.key === 'Escape') {
                loadMoonbirdGameSprites(moonbirdState.selectedId).then(() => {
                    currentState = GAME_STATE.TITLE;
                });
            }
        });

        function drawHowToPlay() {
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const s = Math.min(canvas.width, canvas.height) * 0.035; // responsive font base

            // Title
            ctx.fillStyle = '#0ff';
            ctx.font = `bold ${Math.round(s * 1.4)}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0ff';
            ctx.fillText('HOW TO PLAY', cx, s * 2.5);

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // Instructions with game sprites
            const iconSize = Math.round(s * 2.2);
            const startY = canvas.height * 0.14;
            const lineH = canvas.height * 0.085;
            const iconX = canvas.width * 0.15;
            const textX = canvas.width * 0.58;

            const lines = [
                { img: null, emoji: 'ðŸ‘†', color: '#00ff88', text: 'HOLD to walk' },
                { img: null, emoji: 'âœ‹', color: '#00ff88', text: 'RELEASE to jump' },
                { img: assets.images.coinSprite, color: '#ffd700', text: 'Collect ETH' },
                { img: assets.images.drainer, color: '#ff4444', text: 'Dodge drainers' },
                { img: null, emoji: 'ðŸ›¡ï¸', color: '#ffd700', text: 'Shield blocks' },
                { img: null, emoji: 'ðŸ§²', color: '#ff6600', text: 'Magnet pulls' },
                { img: null, emoji: 'ðŸŒ§ï¸', color: '#00ffcc', text: 'Coin rain!' },
                { img: 'owlHead', color: '#ff6688', text: '3 lives. Go!' },
            ];

            lines.forEach((line, i) => {
                const y = startY + i * lineH;
                // Draw sprite or emoji â€” owl head uses cropped look1
                if (line.img === 'owlHead' && assets.images.look1.complete) {
                    // Same crop as in-game lives HUD
                    const src = assets.images.look1;
                    const sw = src.naturalWidth, sh = src.naturalHeight;
                    const cropX = sw * 0.05, cropY = 0;
                    const cropW = sw * 0.9, cropH = sh * 0.58;
                    const headSize = iconSize * 2.112;
                    const drawH = headSize * (cropH / cropW);
                    ctx.drawImage(src, cropX, cropY, cropW, cropH,
                        iconX - headSize/2 + 2, y - drawH * 0.85 - 9, headSize, drawH);
                } else if (line.img && line.img.complete) {
                    ctx.drawImage(line.img, iconX - iconSize/2, y - iconSize * 0.6, iconSize, iconSize);
                } else if (line.emoji) {
                    ctx.font = `${Math.round(iconSize * 0.8)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(line.emoji, iconX, y + iconSize * 0.15);
                }
                // Text
                ctx.font = `${Math.round(s * 0.85)}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.fillStyle = line.color;
                ctx.fillText(line.text, textX, y);
            });

            // Tap to start â€” raised higher
            ctx.fillStyle = '#0ff';
            ctx.font = `${Math.round(s)}px "Press Start 2P"`;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#0ff';
            const pulseAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 300);
            ctx.globalAlpha = pulseAlpha;
            ctx.fillText('TAP TO START', cx, canvas.height - s * 6);
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // YOU GOT RUGGED - big glitchy red text
            ctx.fillStyle = '#ff0000';
            ctx.font = '28px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff0000';

            // Glitchy effect
            const glitchOffset = Math.random() * 4 - 2;
            ctx.fillText('YOU GOT', canvas.width / 2 + glitchOffset, canvas.height * 0.25);
            ctx.fillText('RUGGED', canvas.width / 2 - glitchOffset, canvas.height * 0.35);

            // Score
            ctx.fillStyle = '#0ff';
            ctx.font = '20px "Press Start 2P"';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 15;
            ctx.fillText(`SCORE: ${gameState.score}`, canvas.width / 2, canvas.height * 0.5);

            // New high score
            if (isHighScore(gameState.score)) {
                ctx.fillStyle = '#ffd700';
                ctx.font = '16px "Press Start 2P"';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, canvas.height * 0.6);
            }

            // Tap to continue
            ctx.fillStyle = '#00ff00';
            ctx.font = '14px "Press Start 2P"';
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.fillText('TAP TO CONTINUE', canvas.width / 2, canvas.height * 0.75);
        }

        function drawHighScores() {
            // Dark cyberpunk background
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title with underline
            ctx.fillStyle = '#0ff';
            ctx.font = '20px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0ff';
            ctx.fillText('GLOBAL HIGH SCORES', canvas.width / 2, 50);

            // Underline
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.2, 60);
            ctx.lineTo(canvas.width * 0.8, 60);
            ctx.stroke();

            // High score entries - each in DIFFERENT COLOR
            ctx.font = '14px "Press Start 2P"';
            gameState.highScores.forEach((entry, i) => {
                const y = 100 + i * 35;
                // Highlight new high score
                if (i === gameState.newHighScoreIndex) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(0, y - 20, canvas.width, 30);
                }

                // All entries bright yellow
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 8;

                // Rank number
                ctx.textAlign = 'left';
                ctx.fillText(`${i + 1}.`, 30, y);

                // Initials
                ctx.fillText(entry.initials, 80, y);

                // Score
                ctx.textAlign = 'right';
                ctx.fillText(entry.score.toString(), canvas.width - 30, y);
            });

            // Back button
            ctx.fillStyle = '#ff0000';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff0000';
            ctx.fillText('TAP TO RETURN', canvas.width / 2, canvas.height - 30);
        }

        function drawEnterInitials() {
            // Dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = '18px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffd700';
            ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, 80);

            // Score
            ctx.fillStyle = '#0ff';
            ctx.font = '16px "Press Start 2P"';
            ctx.shadowColor = '#0ff';
            ctx.fillText(`SCORE: ${gameState.score}`, canvas.width / 2, 120);

            // Instructions
            ctx.fillStyle = '#fff';
            ctx.font = '10px "Press Start 2P"';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#fff';
            ctx.fillText('TAP LETTERS TO CYCLE A-Z', canvas.width / 2, 160);

            // Draw three large letters (tap each to cycle)
            const letterSpacing = 80;
            const startX = canvas.width / 2 - letterSpacing;
            const letterY = 240;

            initialsInput.blinkTimer += 16;
            const blink = Math.floor(initialsInput.blinkTimer / 500) % 2 === 0;

            for (let i = 0; i < 3; i++) {
                const x = startX + i * letterSpacing;

                // Box for letter â€” all bright yellow
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffff00';
                ctx.strokeRect(x - 30, letterY - 45, 60, 60);

                // Letter â€” bright yellow with glow
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffff00';
                ctx.font = '36px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(initialsInput.letters[i], x, letterY);
            }

            // SUBMIT button (green)
            const submitY = 340;
            ctx.fillStyle = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff00';
            ctx.fillRect(canvas.width / 2 - 100, submitY, 200, 50);

            ctx.fillStyle = '#000';
            ctx.font = '14px "Press Start 2P"';
            ctx.shadowBlur = 0;
            ctx.fillText('SUBMIT', canvas.width / 2, submitY + 32);
        }

        // ==========================================
        // GAME LOOP
        // ==========================================

        let lastTime = performance.now();

        function gameLoop(currentTime) {
            let deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            // Cap deltaTime to prevent physics explosions after tab switch or throttle
            // Also prevents "slow motion" from accumulated lag
            if (deltaTime > 100) deltaTime = 16.67; // Reset to ~60fps if gap > 100ms
            if (deltaTime <= 0) deltaTime = 16.67;

            // Apply screen shake
            if (gameState.screenShake > 0) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
                gameState.screenShake *= 0.9;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            switch (currentState) {
                case GAME_STATE.TITLE:
                    drawTitleScreen();
                    break;

                case GAME_STATE.CHOOSE_BIRD:
                    drawChooseBird();
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    drawHowToPlay();
                    break;

                case GAME_STATE.PLAYING:
                    // Update physics
                    updatePhysics(deltaTime);

                    // Animation speed based on state
                    let animRate;
                    if (gameState.isWalking) {
                        animRate = deltaTime * 0.01;  // Walk: ~10fps
                    } else if (!gameState.grounded) {
                        animRate = deltaTime * 0.008;  // Jumping: ~8fps
                    } else {
                        animRate = deltaTime * 0.0092;  // Idle bounce
                    }
                    gameState.playerAnimFrame += animRate;

                    updateGameSpeed(deltaTime);
                    spawnObject();

                    gameState.objects.forEach(obj => obj.update(deltaTime));
                    checkCollisions();

                    if (gameState.magnet) {
                        gameState.magnetTimer -= deltaTime;
                        if (gameState.magnetTimer <= 0) {
                            gameState.magnet = false;
                        }
                    }

                    // Draw
                    drawBackground();
                    gameState.objects.forEach(obj => obj.draw());
                    drawPlayer();

                    // Last life intensity - subtle red vignette pulse
                    if (gameState.lives === 1) {
                        const pulseAlpha = 0.06 + 0.04 * Math.sin(Date.now() / 400);
                        const vGrad = ctx.createRadialGradient(
                            canvas.width/2, canvas.height * PHYSICS.GAME_AREA_RATIO / 2, canvas.width * 0.3,
                            canvas.width/2, canvas.height * PHYSICS.GAME_AREA_RATIO / 2, canvas.width * 0.8
                        );
                        vGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
                        vGrad.addColorStop(1, `rgba(255, 0, 0, ${pulseAlpha})`);
                        ctx.fillStyle = vGrad;
                        ctx.fillRect(0, 0, canvas.width, canvas.height * PHYSICS.GAME_AREA_RATIO);
                    }

                    // (milestone flash removed)

                    // Speed wind lines when going fast
                    if (gameState.bgSpeed > 10) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.lineWidth = 1;
                        const t = Date.now();
                        for (let i = 0; i < 4; i++) {
                            const ly = ((i * 173 + t * 0.03) % (canvas.height * 0.7)) + 20;
                            const lx = (t * (0.8 + i * 0.2)) % canvas.width;
                            ctx.beginPath();
                            ctx.moveTo(lx, ly);
                            ctx.lineTo(lx - 60 - gameState.bgSpeed * 4, ly);
                            ctx.stroke();
                        }
                    }

                    drawUI();
                    break;

                case GAME_STATE.GAME_OVER:
                    drawGameOverScreen();
                    break;

                case GAME_STATE.HIGH_SCORES:
                    drawHighScores();
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    drawEnterInitials();
                    break;
            }

            if (gameState.screenShake > 0) {
                ctx.restore();
            }

            requestAnimationFrame(gameLoop);
        }

        // ==========================================
        // INPUT HANDLING - CRITICAL: Hold to walk, Release to jump
        // ==========================================

        let touchActive = false;

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            enableAudio();

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            switch (currentState) {
                case GAME_STATE.TITLE:
                    // Choose Bird button zone (centered, ~85% height)
                    if (y > canvas.height * 0.81 && y < canvas.height * 0.91) {
                        currentState = GAME_STATE.CHOOSE_BIRD;
                        moonbirdState.inputDigits = moonbirdState.selectedId.toString(); moonbirdState.inputFresh = true; namingOverlay = null;
                        loadMoonbirdPreview(moonbirdState.selectedId);
                    } else if (y > canvas.height * 0.9 && x < canvas.width * 0.5) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else if (y > canvas.height * 0.9 && x >= canvas.width * 0.5) {
                        currentState = GAME_STATE.HIGH_SCORES;
                    } else if (!localStorage.getItem('etherDashTutorialSeen')) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else {
                        startGameWithBird();
                    }
                    break;

                case GAME_STATE.CHOOSE_BIRD:
                    handleChooseBirdClick(x, y);
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    localStorage.setItem('etherDashTutorialSeen', '1');
                    startGameWithBird();
                    break;

                case GAME_STATE.PLAYING:
                    // Check quit button first (bottom-left corner)
                    if (x < 58 && y > canvas.height - 24) {
                        stopMusic();
                        currentState = GAME_STATE.TITLE;
                        break;
                    }
                    // HOLD = WALK
                    startHolding();
                    touchActive = true;
                    break;

                case GAME_STATE.GAME_OVER:
                    if (isHighScore(gameState.score)) {
                        initialsInput = { letters: ['A', 'A', 'A'], currentIndex: 0, blinkTimer: 0 };
                        currentState = GAME_STATE.ENTER_INITIALS;
                    } else {
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;

                case GAME_STATE.HIGH_SCORES:
                    currentState = GAME_STATE.TITLE;
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    // Check which letter was tapped
                    const letterSpacing = 80;
                    const startX = canvas.width / 2 - letterSpacing;
                    const letterY = 240;

                    for (let i = 0; i < 3; i++) {
                        const lx = startX + i * letterSpacing;
                        if (x > lx - 30 && x < lx + 30 && y > letterY - 45 && y < letterY + 15) {
                            cycleInitialLetter(i);
                            break;
                        }
                    }

                    // Check submit button
                    const submitY = 340;
                    if (y > submitY && y < submitY + 50 && x > canvas.width / 2 - 100 && x < canvas.width / 2 + 100) {
                        const initials = initialsInput.letters.join('');
                        addHighScore(initials, gameState.score);
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();

            // RELEASE = JUMP
            if (currentState === GAME_STATE.PLAYING && touchActive) {
                releaseHolding();
                touchActive = false;
            }
        }, { passive: false });

        // Mouse events for desktop testing
        canvas.addEventListener('mousedown', (e) => {
            enableAudio();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            switch (currentState) {
                case GAME_STATE.TITLE:
                    // Choose Bird button zone (centered, ~85% height)
                    if (y > canvas.height * 0.81 && y < canvas.height * 0.91) {
                        currentState = GAME_STATE.CHOOSE_BIRD;
                        moonbirdState.inputDigits = moonbirdState.selectedId.toString(); moonbirdState.inputFresh = true; namingOverlay = null;
                        loadMoonbirdPreview(moonbirdState.selectedId);
                    } else if (y > canvas.height * 0.9 && x < canvas.width * 0.5) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else if (y > canvas.height * 0.9 && x >= canvas.width * 0.5) {
                        currentState = GAME_STATE.HIGH_SCORES;
                    } else if (!localStorage.getItem('etherDashTutorialSeen')) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else {
                        startGameWithBird();
                    }
                    break;

                case GAME_STATE.CHOOSE_BIRD:
                    handleChooseBirdClick(x, y);
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    localStorage.setItem('etherDashTutorialSeen', '1');
                    startGameWithBird();
                    break;

                case GAME_STATE.PLAYING:
                    // Check quit button (bottom-left corner)
                    if (x < 58 && y > canvas.height - 24) {
                        stopMusic();
                        currentState = GAME_STATE.TITLE;
                        break;
                    }
                    startHolding();
                    touchActive = true;
                    break;

                case GAME_STATE.GAME_OVER:
                    if (isHighScore(gameState.score)) {
                        initialsInput = { letters: ['A', 'A', 'A'], currentIndex: 0, blinkTimer: 0 };
                        currentState = GAME_STATE.ENTER_INITIALS;
                    } else {
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;

                case GAME_STATE.HIGH_SCORES:
                    currentState = GAME_STATE.TITLE;
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    const letterSpacing = 80;
                    const startX = canvas.width / 2 - letterSpacing;
                    const letterY = 240;

                    for (let i = 0; i < 3; i++) {
                        const lx = startX + i * letterSpacing;
                        if (x > lx - 30 && x < lx + 30 && y > letterY - 45 && y < letterY + 15) {
                            cycleInitialLetter(i);
                            break;
                        }
                    }

                    const submitY = 340;
                    if (y > submitY && y < submitY + 50 && x > canvas.width / 2 - 100 && x < canvas.width / 2 + 100) {
                        const initials = initialsInput.letters.join('');
                        addHighScore(initials, gameState.score);
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (currentState === GAME_STATE.PLAYING && touchActive) {
                releaseHolding();
                touchActive = false;
            }
        });

        // Keyboard controls for desktop testing
        let keyHeld = false;
        document.addEventListener('keydown', (e) => {
            if (currentState === GAME_STATE.PLAYING) {
                if ((e.key === ' ' || e.key === 'ArrowDown' || e.key === 's') && !keyHeld) {
                    e.preventDefault();
                    startHolding();
                    keyHeld = true;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (currentState === GAME_STATE.PLAYING) {
                if (e.key === ' ' || e.key === 'ArrowDown' || e.key === 's') {
                    e.preventDefault();
                    releaseHolding();
                    keyHeld = false;
                }
            }
        });

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
