<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>Ether Dash</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background: #000;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            display: block;
            background: #1a0033;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
            font-size: 12px;
            z-index: 1000;
        }

        .loading-text {
            margin-top: 20px;
        }

        .loading-bar {
            width: 200px;
            height: 20px;
            border: 2px solid #0ff;
            margin-top: 10px;
            position: relative;
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #f0f);
            width: 0%;
            transition: width 0.3s;
        }

        .glow {
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="loadingScreen">
        <div class="glow" style="font-size: 20px;">ETHER DASH</div>
        <div class="loading-text">Loading...</div>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
    </div>

    <script>
        // ==========================================
        // ETHER DASH - Mobile Runner Game
        // ==========================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingFill = document.getElementById('loadingFill');

        // Canvas setup for portrait mobile
        function resizeCanvas() {
            const aspectRatio = 9 / 16;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            if (windowWidth / windowHeight > aspectRatio) {
                canvas.height = windowHeight;
                canvas.width = windowHeight * aspectRatio;
            } else {
                canvas.width = windowWidth;
                canvas.height = windowWidth / aspectRatio;
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==========================================
        // GAME STATE
        // ==========================================

        const GAME_STATE = {
            LOADING: 'loading',
            TITLE: 'title',
            HOW_TO_PLAY: 'howToPlay',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver',
            HIGH_SCORES: 'highScores',
            ENTER_INITIALS: 'enterInitials'
        };

        let currentState = GAME_STATE.LOADING;

        // ==========================================
        // ASSET LOADING
        // ==========================================

        const assets = {
            images: {},
            audio: {},
            loaded: 0,
            total: 0
        };

        const imagesToLoad = {
            background: 'Background.png',
            title: 'Title.jpg',
            ethCoin: 'EthCoin.png',
            drainer: 'Drainer.png',
            drainer2: 'Drainer2.png',
            coinSprite: 'sprites/coin.png',
            cashoutSprite: 'sprites/cashout.png',
            jump1: 'sprites/Jump 1.png',
            jump2: 'sprites/Jump 2.png',
            jump3: 'sprites/Jump 3.png',
            jump4: 'sprites/Jump 4.png',
            jump5: 'sprites/Jump 5.png',
            jump6: 'sprites/Jump 6.png',
            walk1: 'sprites/walk_1.png',
            walk2: 'sprites/walk_2.png',
            walk3: 'sprites/walk_3.png',
            walk4: 'sprites/walk_4.png',
            walk5: 'sprites/walk_5.png',
            walk6: 'sprites/walk_6.png',
            look1: 'sprites/look_1.png',
            look2: 'sprites/look_2.png',
            look3: 'sprites/look_3.png',
            look4: 'sprites/look_4.png',
            look5: 'sprites/look_5.png',
            look6: 'sprites/look_6.png'
        };

        const audioToLoad = {
            coin: 'audio/Coin.mp3',
            drain: 'audio/Drain.mp3',
            jump: 'audio/Jump.mp3',
            money: 'audio/Money.mp3',
            bgMusic: 'audio/Ether M1.mp3',
            hiScoreMusic: 'audio/HiS.mp3',
            textSound: 'audio/Text.mp3'
        };

        assets.total = Object.keys(imagesToLoad).length + Object.keys(audioToLoad).length;

        function updateLoadingBar() {
            const percent = (assets.loaded / assets.total) * 100;
            loadingFill.style.width = percent + '%';

            if (assets.loaded === assets.total) {
                
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    currentState = GAME_STATE.TITLE;
                }, 500);
            }
        }

        // Load images
        Object.keys(imagesToLoad).forEach(key => {
            const img = new Image();
            img.onload = () => {
                assets.loaded++;
                updateLoadingBar();
            };
            img.onerror = () => {
                console.warn(`Failed to load image: ${imagesToLoad[key]}`);
                assets.loaded++;
                updateLoadingBar();
            };
            img.src = imagesToLoad[key];
            assets.images[key] = img;
        });

        // Load audio
        Object.keys(audioToLoad).forEach(key => {
            const audio = new Audio();
            audio.oncanplaythrough = () => {
                assets.loaded++;
                updateLoadingBar();
            };
            audio.onerror = () => {
                console.warn(`Failed to load audio: ${audioToLoad[key]}`);
                assets.loaded++;
                updateLoadingBar();
            };
            audio.src = audioToLoad[key];
            audio.load();
            assets.audio[key] = audio;
        });

        // Audio system - Web Audio API for sound effects
        let audioEnabled = false;
        let musicStarted = false;
        let audioCtx = null;
        const audioBuffers = {};
        const audioRawData = {};

        // Pre-fetch audio files immediately (no user gesture needed for fetch)
        const soundFiles = {
            jump: 'audio/Jump.mp3',
            // coin embedded as base64 below
            drain: 'audio/Drain.mp3',
            money: 'audio/Money.mp3',
            textSound: 'audio/Text.mp3'
        };
        const fetchPromises = [];
        for (const [name, url] of Object.entries(soundFiles)) {
            const p = fetch(url).then(r => r.arrayBuffer()).then(buf => {
                audioRawData[name] = buf;
            }).catch(() => {});
            fetchPromises.push(p);
        }
        const allFetched = Promise.all(fetchPromises);

        // Coin sound embedded as base64 — available instantly, no fetch needed
        (function() {
            const b64 = 'SUQzAgAAAAAPdlRDTQAABwBkZXJpawBUVDEAABwAVGhpcyB2aWRlbyBpcyBhYm91dCBKdW1wIDEAVFQyAAAIAEp1bXAgMQBURU4AACEARmluYWwgQ3V0IFBybyAxMC43LjEgKEFwcGxlIE1QMwBBcHBsZSBNUDMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/70AA+gAAAADeAAAAAAAAG8AAAAAAAAN4AAAAAAAAbwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=';
            const bin = atob(b64);
            const bytes = new Uint8Array(bin.length);
            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
            audioRawData['coin'] = bytes.buffer;
        })();

        async function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            await decodeAllPending();
            allFetched.then(() => decodeAllPending());
        }

        async function decodeAllPending() {
            if (!audioCtx) return;
            for (const [name, buf] of Object.entries(audioRawData)) {
                if (!audioBuffers[name]) {
                    try {
                        audioBuffers[name] = await audioCtx.decodeAudioData(buf.slice(0));
                    } catch(e) {
                        console.warn('Failed to decode sound:', name);
                    }
                }
            }
            // Check if all sounds are decoded
            const allDecoded = Object.keys(soundFiles).every(n => audioBuffers[n]);
        }

        function playSound(name) {
            if (!audioEnabled || !audioCtx) return;
            // Synthesized shield block sound
            if (name === 'shieldBlock') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.2);
                return;
            }
            if (!audioBuffers[name]) {
                // Try late decode if raw data arrived after initAudio — play once ready
                if (audioRawData[name]) {
                    audioCtx.decodeAudioData(audioRawData[name].slice(0)).then(buf => {
                        audioBuffers[name] = buf;
                        const s = audioCtx.createBufferSource();
                        s.buffer = buf;
                        s.connect(audioCtx.destination);
                        s.start(0);
                    }).catch(() => {});
                }
                return;
            }
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffers[name];
            source.connect(audioCtx.destination);
            source.start(0);
        }

        function startMusic() {
            if (!audioEnabled || musicStarted) return;
            const music = assets.audio.bgMusic;
            if (music) {
                music.loop = true;
                music.volume = 0.5;
                music.play().catch(e => console.warn('Music play failed:', e));
                musicStarted = true;
            }
        }

        function enableAudio() {
            if (!audioEnabled) {
                audioEnabled = true;
                // Create AudioContext synchronously in user gesture (Chrome requirement)
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
            }
            // Chrome suspends AudioContext until user gesture — MUST resume first
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    decodeAllPending();
                    allFetched.then(() => decodeAllPending());
                });
            } else if (audioCtx) {
                decodeAllPending();
                allFetched.then(() => decodeAllPending());
            }
        }

        // Audio context created on first user gesture (enableAudio), raw files pre-fetched above

        // ==========================================
        // GAME VARIABLES
        // ==========================================

        // Physics constants - matching iOS original
        const PHYSICS = {
            GRAVITY: 0.9,
            JUMP_FORCE: -20,
            GAME_AREA_RATIO: 0.8,  // Top 80% is game area
            HOLD_ZONE_RATIO: 0.2,  // Bottom 20% is hold zone
            GROUND_Y_RATIO: 0.72,  // Owl feet on the black line above the railing
            PLAYER_X_RATIO: 0.3,   // Player at 30% from left
            WALK_SPEED_MULTIPLIER: 1,  // Direct speed when walking (applied to base walk speed)
            IDLE_SPEED: 0,  // No scroll when idle — owl only moves when you hold
            JUMP_SPEED_MULTIPLIER: 1.0  // Same speed as running
        };

        let gameState = {
            score: 0,
            coinsCollected: 0,  // Track coins separately from score
            lives: 3,  // Lives system
            combo: 0,
            comboMultiplier: 1,
            shieldCount: 0,  // 0=none, 1=single shield, 2=double shield
            invincibleTimer: 0,  // i-frames after taking damage (ms)
            coinRainTimer: 0,  // coin rain powerup duration (ms)
            magnet: false,
            magnetTimer: 0,
            bgScroll: 0,
            bgSpeed: PHYSICS.IDLE_SPEED,
            playerY: 0,  // Actual Y position
            playerVelocityY: 0,  // Vertical velocity
            playerX: 0,  // Fixed X position (30% from left)
            grounded: true,
            isHolding: false,  // CRITICAL: track if player is holding
            isWalking: false,  // Track walking state
            playerAnimFrame: 0,
            playerAnimTimer: 0,
            walkAnimSpeed: 0.07,  // timePerFrame for walk
            jumpAnimSpeed: 0.1,   // timePerFrame for jump
            objects: [],
            particles: [],
            screenShake: 0,
            lastSpawnTime: 0,
            spawnInterval: 400,  // Fast spawns — screen full of coins
            gameTime: 0,
            drainersEnabled: false,
            highScores: [],
            lastDrainerX: -1000,
            milestoneReached: 0,
            newHighScoreIndex: -1,  // For highlighting new score
            compromiseMessage: '',  // Current compromise message
            compromiseMessageLife: 0,  // Life timer for message
            milestoneFlash: 0  // White flash for milestone celebrations
        };

        // Get ground level Y position
        function getGroundY() {
            return canvas.height * PHYSICS.GROUND_Y_RATIO;
        }

        // Get player size (larger than before - 2.1x scale like original)
        function getPlayerSize() {
            return Math.min(canvas.height * 0.11, 110);  // Smaller — more room to dodge
        }

        // ==========================================
        // HIGH SCORE SYSTEM
        // ==========================================

        const HIGH_SCORE_COLORS = [
            '#ff0000',  // red
            '#00ff00',  // green
            '#ffff00',  // yellow
            '#0000ff',  // blue
            '#00ffff',  // cyan
            '#ff00ff',  // magenta
            '#ff8800',  // orange
            '#8800ff',  // purple
            '#884400',  // brown
            '#aaaaaa'   // lightGray
        ];

        const LEADERBOARD_URL = 'https://tomatobird.xyz/api/scores';

        function loadHighScores() {
            // Load local scores first (instant)
            const saved = localStorage.getItem('etherDashHighScores');
            if (saved) {
                gameState.highScores = JSON.parse(saved);
            } else {
                gameState.highScores = [];
            }

            // Then fetch global scores and merge
            fetch(LEADERBOARD_URL)
                .then(r => r.json())
                .then(globalScores => {
                    if (Array.isArray(globalScores)) {
                        // Merge local and global, dedupe, keep top 10
                        const all = [...gameState.highScores, ...globalScores];
                        const seen = new Set();
                        const unique = all.filter(e => {
                            const key = e.initials + ':' + e.score;
                            if (seen.has(key)) return false;
                            seen.add(key);
                            return true;
                        });
                        unique.sort((a, b) => b.score - a.score);
                        gameState.highScores = unique.slice(0, 10);
                        saveHighScores();
                    }
                })
                .catch(() => {}); // silently fail — local scores still work
        }

        function saveHighScores() {
            localStorage.setItem('etherDashHighScores', JSON.stringify(gameState.highScores));
        }

        function addHighScore(initials, score) {
            gameState.highScores.push({ initials, score, date: Date.now() });
            gameState.highScores.sort((a, b) => b.score - a.score);
            gameState.highScores = gameState.highScores.slice(0, 10);

            // Find the index of the new score
            gameState.newHighScoreIndex = gameState.highScores.findIndex(entry =>
                entry.initials === initials && entry.score === score
            );

            saveHighScores();

            // Submit to global leaderboard (atomic — server handles merge)
            fetch(LEADERBOARD_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ initials, score })
            })
            .then(r => r.json())
            .then(data => {
                if (data.scores) {
                    gameState.highScores = data.scores;
                    saveHighScores();
                }
            })
            .catch(() => {});
        }

        function isHighScore(score) {
            return gameState.highScores.length < 10 || score > gameState.highScores[gameState.highScores.length - 1].score;
        }

        loadHighScores();

        // ==========================================
        // INITIALS INPUT SYSTEM
        // ==========================================

        let initialsInput = {
            letters: ['A', 'A', 'A'],
            currentIndex: 0,
            blinkTimer: 0
        };

        function cycleInitialLetter(index) {
            const current = initialsInput.letters[index];
            const charCode = current.charCodeAt(0);
            if (charCode >= 90) {  // Z wraps to A
                initialsInput.letters[index] = 'A';
            } else {
                initialsInput.letters[index] = String.fromCharCode(charCode + 1);
            }
            playSound('textSound');
        }

        // Music management
        function stopMusic() {
            musicStarted = false;
            const music = assets.audio.bgMusic;
            if (music) { music.pause(); music.currentTime = 0; }
            const hsMusic = assets.audio.hiScoreMusic;
            if (hsMusic) { hsMusic.pause(); hsMusic.currentTime = 0; }
        }

        // Pause all audio when tab/app is hidden (switching apps, locking phone)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const music = assets.audio.bgMusic;
                if (music && !music.paused) music.pause();
                const hsMusic = assets.audio.hiScoreMusic;
                if (hsMusic && !hsMusic.paused) hsMusic.pause();
                if (audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            } else {
                // Resume when coming back
                if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
                if (currentState === GAME_STATE.PLAYING && musicStarted) {
                    const music = assets.audio.bgMusic;
                    if (music && music.paused) music.play().catch(() => {});
                } else if (currentState === GAME_STATE.GAME_OVER || currentState === GAME_STATE.HIGH_SCORES || currentState === GAME_STATE.ENTER_INITIALS) {
                    const hsMusic = assets.audio.hiScoreMusic;
                    if (hsMusic && hsMusic.paused) hsMusic.play().catch(() => {});
                }
            }
        });

        function playHiScoreMusic() {
            stopMusic();
            if (!audioEnabled) return;
            const music = assets.audio.hiScoreMusic;
            if (music) {
                music.loop = true;
                music.volume = 0.5;
                music.play().catch(() => {});
            }
        }

        // ==========================================
        // GAME OBJECTS
        // ==========================================

        class GameObject {
            constructor(type, heightType, x) {
                this.type = type;
                this.heightType = heightType;
                this.x = x;
                this.y = this.getYPosition(heightType);
                // Drainers ~10% bigger than coins
                const sz = (type === 'drainer') ? 46 : 42;
                this.width = sz;
                this.height = sz;
                this.collected = false;
                this.pulseTime = 0;
                this.bobOffset = 0;
                this.falling = false;  // rain coins fall straight down
                this.fallSpeed = 0;
            }

            getYPosition(heightType) {
                const groundY = getGroundY();
                const playerSize = getPlayerSize();
                if (heightType === 'ground') {
                    return groundY - playerSize * 0.6;  // Coin at owl body height
                } else if (heightType === 'lower') {
                    return groundY - canvas.height * 0.2;  // Low jump
                } else {  // 'upper'
                    return groundY - canvas.height * 0.35;  // High jump
                }
            }

            update(deltaTime) {
                // Rain coins fall down AND scroll left with the background
                if (this.falling) {
                    this.y += this.fallSpeed * (deltaTime / 16);
                    let speed = gameState.bgSpeed;
                    if (!gameState.grounded) speed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
                    this.x -= speed;
                    this.pulseTime += deltaTime;
                    this.bobOffset = 0;
                    // Magnet pulls rain coins too
                    if (gameState.magnet && this.type === 'coin') {
                        const dx = gameState.playerX - this.x;
                        const dy = gameState.playerY - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 350) {
                            const pullStrength = 10 + (350 - distance) * 0.03;
                            this.x += (dx / distance) * pullStrength;
                            this.y += (dy / distance) * pullStrength;
                        }
                    }
                    return;
                }

                let speed = gameState.bgSpeed;

                // Jump moves forward - objects scroll faster when in air
                if (!gameState.grounded) {
                    speed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
                }

                this.x -= speed;
                this.pulseTime += deltaTime;

                // Powerups float gently, coins and drainers stay still
                if (this.type !== 'drainer' && this.type !== 'coin') {
                    this.bobOffset = Math.sin(this.pulseTime / 400) * 5;
                } else {
                    this.bobOffset = 0;
                }

                // Magnet pull - only affects coins, not drainers
                // Magnet pull — stronger, wider range
                if (gameState.magnet && this.type === 'coin') {
                    const playerX = gameState.playerX;
                    const playerY = gameState.playerY;
                    const dx = playerX - this.x;
                    const dy = playerY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 350) {
                        const pullStrength = 10 + (350 - distance) * 0.03;
                        this.x += (dx / distance) * pullStrength;
                        this.y += (dy / distance) * pullStrength;
                    }
                }

                // (all drainers same size now)
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                const drawX = this.x;
                const drawY = this.y - this.height / 2 + this.bobOffset;

                // Draw based on type (no shadowBlur for performance)
                switch (this.type) {
                    case 'coin':
                        if (assets.images.coinSprite.complete) {
                            // Magnet trail effect
                            if (gameState.magnet) {
                                ctx.globalAlpha = 0.15;
                                ctx.drawImage(assets.images.coinSprite, drawX - this.width/2 + 16, drawY, this.width, this.height);
                                ctx.globalAlpha = 0.3;
                                ctx.drawImage(assets.images.coinSprite, drawX - this.width/2 + 8, drawY, this.width, this.height);
                                ctx.globalAlpha = 1;
                            }
                            ctx.drawImage(assets.images.coinSprite, drawX - this.width/2, drawY, this.width, this.height);
                        }
                        break;
                    case 'drainer':
                        // Big drainers use drainer2 sprite
                        if (assets.images.drainer.complete) {
                            ctx.drawImage(assets.images.drainer, drawX - this.width/2, drawY, this.width, this.height);
                        }
                        break;
                    case 'extraLife':
                    case 'shield':
                    case 'magnet':
                    case 'coinRain':
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffffff';
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        const emojiMap = { extraLife: '❤️', shield: '🛡️', magnet: '🧲', coinRain: '🌧️' };
                        ctx.fillText(emojiMap[this.type], drawX, drawY + this.height/2 + 12);
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        break;
                }

                ctx.restore();
            }

            isOffScreen() {
                if (this.falling) {
                    return this.x < -this.width || this.y > canvas.height * PHYSICS.GAME_AREA_RATIO;
                }
                return this.x < -this.width;
            }

            // Bounding box collision detection
            collidesWith(x, y, width, height) {
                // Tighter hitbox — 65% of visual size for precise feel
                const margin = this.width * 0.175;
                const objLeft = this.x - this.width / 2 + margin;
                const objRight = this.x + this.width / 2 - margin;
                const objTop = this.y - this.height / 2 + margin + this.bobOffset;
                const objBottom = this.y + this.height / 2 - margin + this.bobOffset;

                const playerLeft = x;
                const playerRight = x + width;
                const playerTop = y;
                const playerBottom = y + height;

                return objLeft < playerRight &&
                       objRight > playerLeft &&
                       objTop < playerBottom &&
                       objBottom > playerTop;
            }
        }


        // ==========================================
        // GAME LOGIC
        // ==========================================

        function resetGame() {
            gameState.score = 0;
            gameState.coinsCollected = 0;
            gameState.lives = 3;
            gameState.combo = 0;
            gameState.comboMultiplier = 1;
            gameState.shieldCount = 0;
            gameState.invincibleTimer = 0;
            gameState.coinRainTimer = 0;
            gameState.magnet = false;
            gameState.magnetTimer = 0;
            gameState.speedBoost = false;
            gameState.speedBoostTimer = 0;
            gameState.bgScroll = 0;
            gameState.bgSpeed = 0;
            gameState.walkSpeedBonus = 0;
            gameState.playerY = getGroundY();
            gameState.playerVelocityY = 0;
            gameState.playerX = canvas.width * PHYSICS.PLAYER_X_RATIO;
            gameState.grounded = true;
            gameState.isHolding = false;
            gameState.isWalking = false;
            gameState.objects = [];
            gameState.floatingTexts = [];
            gameState.particles = [];
            gameState.screenShake = 0;
            gameState.lastSpawnTime = 0;
            gameState.spawnInterval = 400;
            gameState.gameTime = 0;
            gameState.drainersEnabled = false;
            gameState.milestoneReached = 0;
            gameState.lastDrainerX = -1000;
            gameState.newHighScoreIndex = -1;
            gameState.compromiseMessage = '';
            gameState.compromiseMessageLife = 0;
            gameState.closeCallMessage = '';
            gameState.closeCallLife = 0;
            gameState.milestoneFlash = 0;
            gameState.lastMilestone = 0;
        }

        function spawnObject() {
            const now = Date.now();
            if (now - gameState.lastSpawnTime < gameState.spawnInterval) return;

            gameState.lastSpawnTime = now;

            // Coin rain mode: spawn extra coins
            const spawnCount = gameState.coinRainTimer > 0 ? 4 : 2;  // 2 base, 4 during rain

            for (let s = 0; s < spawnCount; s++) {
                // THREE Y positions: ground, lower air, upper air
                const rand = Math.random();
                const heightType = rand < 0.35 ? 'ground' : (rand < 0.7 ? 'lower' : 'upper');

                let type = 'coin';

                // Only first spawn per tick can be drainer/powerup (rest are coins)
                if (s === 0) {
                    // Drainer logic - 5% for first 15 coins, then ramps 15%→35% over ~90s
                    const gameTimeSec = gameState.gameTime / 1000;
                    if (gameState.drainersEnabled) {
                        const drainerProb = gameState.coinsCollected < 15
                            ? 0.05
                            : Math.min(0.35, 0.15 + (gameTimeSec / 90) * 0.20);
                        if (Math.random() < drainerProb) {
                            type = 'drainer';
                        }
                    }

                    // Powerup logic - more frequent now
                    const powerupChance = Math.min(0.18, 0.08 + gameTimeSec / 400);
                    if (type === 'coin' && Math.random() < powerupChance) {
                        const r = Math.random();
                        if (r < 0.35) type = 'shield';
                        else if (r < 0.7) type = 'magnet';
                        else type = 'coinRain';
                    }

                    // Extra life — very rare, only when damaged
                    if (type === 'coin' && Math.random() < 0.008 && gameState.lives < 3) {
                        type = 'extraLife';
                    }
                }

                // Check for overlap with existing objects near spawn point
                const xOffset = canvas.width + 100 + s * 80;  // stagger spawns
                const newObj = new GameObject(type, heightType, xOffset);

                const overlaps = gameState.objects.some(obj =>
                    Math.abs(obj.x - newObj.x) < 50 && Math.abs(obj.y - newObj.y) < 50
                );
                if (!overlaps && gameState.objects.length < 25) {
                    gameState.objects.push(newObj);
                }
            }

            // Coin rain: dense shower from top-right, angled toward player
            if (gameState.coinRainTimer > 0) {
                const rainCount = 4;  // 4 rain coins per spawn tick
                for (let r = 0; r < rainCount; r++) {
                    const rainCoin = new GameObject('coin', 'upper', 0);
                    // Spawn off-screen right so player runs into the rain
                    rainCoin.x = canvas.width + Math.random() * canvas.width * 0.5;
                    rainCoin.y = -20 - Math.random() * 100;
                    rainCoin.falling = true;
                    rainCoin.fallSpeed = 8 + Math.random() * 5;  // fast rain
                    if (gameState.objects.length < 35) {
                        gameState.objects.push(rainCoin);
                    }
                }
            }
        }

        // CRITICAL: New control system - HOLD to walk, RELEASE to jump
        function startHolding() {
            gameState.isHolding = true;

            // If grounded, immediately start walking
            if (gameState.grounded) {
                gameState.isWalking = true;
                gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);  // Faster base speed
            }
        }

        function releaseHolding() {
            gameState.isHolding = false;
            gameState.isWalking = false;

            // RELEASE = JUMP (only if grounded)
            if (gameState.grounded) {
                gameState.playerVelocityY = PHYSICS.JUMP_FORCE;
                gameState.grounded = false;
                // Keep moving during jump — maintain walk speed (jump multiplier handled in object update)
                gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);

                // Play jump sound ONLY when jump actually happens
                playSound('jump');
            } else {
                // Released while in air — stop when landing
                gameState.bgSpeed = 0;
            }
        }

        function updatePhysics(deltaTime) {
            // Apply gravity
            gameState.playerVelocityY += PHYSICS.GRAVITY;

            // Update position
            gameState.playerY += gameState.playerVelocityY;

            // Ground collision
            const groundY = getGroundY();
            if (gameState.playerY >= groundY) {
                gameState.playerY = groundY;
                gameState.playerVelocityY = 0;
                gameState.grounded = true;

                // If player is still holding when landing, start walking again
                if (gameState.isHolding) {
                    gameState.isWalking = true;
                    gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);  // Faster base speed
                } else {
                    // Idle bounce - no walking
                    gameState.isWalking = false;
                    gameState.bgSpeed = 0;
                }
            }

            // Don't go above screen
            if (gameState.playerY < 50) {
                gameState.playerY = 50;
                gameState.playerVelocityY = 0;
            }

            // Background scrolling — faster during jump
            let scrollSpeed = gameState.bgSpeed;
            if (!gameState.grounded && scrollSpeed > 0) {
                scrollSpeed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
            }
            gameState.bgScroll += scrollSpeed;
        }

        function updateGameSpeed(deltaTime) {
            gameState.gameTime += deltaTime;

            // Increase difficulty every 15 seconds (smoother ramp)
            if (Math.floor(gameState.gameTime / 15000) > Math.floor((gameState.gameTime - deltaTime) / 15000)) {
                gameState.walkSpeedBonus = (gameState.walkSpeedBonus || 0) + 0.3;
                gameState.spawnInterval = Math.max(300, gameState.spawnInterval - 30);
            }
            // Apply walk speed bonus when walking
            if (gameState.isWalking) {
                gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);  // Faster base speed
            }

            // Drainers enabled from the start
            gameState.drainersEnabled = true;

            // Visual milestones
            if (gameState.score >= 200 && gameState.milestoneReached < 3) {
                gameState.milestoneReached = 3;
            } else if (gameState.score >= 100 && gameState.milestoneReached < 2) {
                gameState.milestoneReached = 2;
            } else if (gameState.score >= 50 && gameState.milestoneReached < 1) {
                gameState.milestoneReached = 1;
            }

            // Update compromise message timer
            if (gameState.compromiseMessageLife > 0) {
                gameState.compromiseMessageLife -= deltaTime;
            }

            // Update invincibility timer
            if (gameState.invincibleTimer > 0) {
                gameState.invincibleTimer -= deltaTime;
            }

            // Update coin rain timer
            if (gameState.coinRainTimer > 0) {
                gameState.coinRainTimer -= deltaTime;
            }
        }

        function checkCollisions() {
            const playerX = gameState.playerX;
            const playerY = gameState.playerY;
            const playerSize = getPlayerSize();

            gameState.objects.forEach((obj, index) => {
                if (obj.collected) return;

                // Position-based bounding box collision - playerY is at feet, sprite extends upward
                // Tighter player hitbox — 70% of sprite
                const hitMargin = playerSize * 0.15;
                if (obj.collidesWith(playerX - playerSize/2 + hitMargin, playerY - playerSize + hitMargin, playerSize - hitMargin*2, playerSize - hitMargin*2)) {
                    obj.collected = true;

                    switch (obj.type) {
                        case 'coin':
                            gameState.score += 1;
                            gameState.coinsCollected++;

                            playSound('coin');
                            break;

                        case 'drainer':
                            if (gameState.invincibleTimer > 0) {
                                // i-frames active, ignore hit
                                obj.collected = false;  // don't consume the drainer
                                return;
                            }
                            if (gameState.shieldCount > 0) {
                                gameState.shieldCount--;
                                playSound('shieldBlock');
                            } else {
                                // Lose a life
                                gameState.lives--;
                                gameState.invincibleTimer = 1500;  // 1.5s i-frames after taking damage
                                gameState.combo = 0;
                                gameState.comboMultiplier = 1;
                                gameState.screenShake = 15;
                                playSound('drain');

                                // Random compromise message
                                const messages = [
                                    'Wallet compromised!',
                                    'Seed phrase leaked!',
                                    'Connected to malicious dApp!',
                                    'Approved unlimited spend!',
                                    'Phishing link clicked!',
                                    'Rug pull detected!',
                                    'Private key exposed!',
                                    'Smart contract exploit!'
                                ];
                                gameState.compromiseMessage = messages[Math.floor(Math.random() * messages.length)];
                                gameState.compromiseMessageLife = 1500;  // Show for 1.5 seconds

                                // Check for game over
                                if (gameState.lives <= 0) {
                                    currentState = GAME_STATE.GAME_OVER; stopMusic(); playHiScoreMusic();
                                }
                            }
                            break;

                        case 'shield':
                            gameState.shieldCount = Math.min(gameState.shieldCount + 1, 2);
                            playSound('coin');
                            break;

                        case 'magnet':
                            gameState.magnet = true;
                            gameState.magnetTimer = 4000;
                            playSound('coin');
                            break;

                        case 'coinRain':
                            gameState.coinRainTimer = 5000;  // 5 seconds of coin rain
                            playSound('coin');
                            break;

                        case 'extraLife':
                            gameState.lives = Math.min(3, gameState.lives + 1);
                            playSound('money');
                            gameState.milestoneFlash = 200;
                            break;
                    }
                }

                // (close call removed)
            });

            // Remove collected and off-screen objects
            gameState.objects = gameState.objects.filter(obj => !obj.collected && !obj.isOffScreen());

            // Missed coin tracking (combo removed)
            gameState.objects.forEach(obj => {
                if (false) { // combo removed
                }
            });
        }


        // ==========================================
        // DRAWING FUNCTIONS
        // ==========================================

        function drawBackground() {
            ctx.save();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // Background tint based on milestone
            let tint = '#1a0033';
            if (gameState.milestoneReached >= 3) {
                tint = '#330066';
            } else if (gameState.milestoneReached >= 2) {
                tint = '#220044';
            } else if (gameState.milestoneReached >= 1) {
                tint = '#1a0040';
            }

            ctx.fillStyle = tint;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw scrolling background in top 80% (game area)
            if (assets.images.background.complete) {
                const gameAreaHeight = canvas.height * PHYSICS.GAME_AREA_RATIO;
                const bgOffsetY = 0;
                const bgHeight = gameAreaHeight;
                const bgWidth = assets.images.background.width * (bgHeight / assets.images.background.height);
                const scrollX = -gameState.bgScroll % bgWidth;

                ctx.globalAlpha = 0.7;
                ctx.drawImage(assets.images.background, scrollX, bgOffsetY, bgWidth, bgHeight);
                ctx.drawImage(assets.images.background, scrollX + bgWidth, bgOffsetY, bgWidth, bgHeight);
                ctx.globalAlpha = 1.0;
            }

            // Draw hold zone at bottom 20%
            const holdZoneY = canvas.height * PHYSICS.GAME_AREA_RATIO;
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, holdZoneY, canvas.width, canvas.height * PHYSICS.HOLD_ZONE_RATIO);

            // Hold zone text — yellow for visibility
            ctx.fillStyle = '#ffff00';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.isHolding ? 'LET GO TO JUMP' : 'HOLD TO RUN', canvas.width / 2, holdZoneY + canvas.height * PHYSICS.HOLD_ZONE_RATIO / 2);

            ctx.restore();
        }

        function drawPlayer() {
            // Invincibility flashing — skip drawing every other 100ms
            if (gameState.invincibleTimer > 0) {
                if (Math.floor(gameState.invincibleTimer / 100) % 2 === 0) {
                    return;  // invisible frame — creates flashing effect
                }
            }

            const playerX = gameState.playerX;
            const playerY = gameState.playerY;
            const playerSize = getPlayerSize();

            ctx.save();
            // Always reset shadow first — no glow by default
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            const owlCenterY = playerY - playerSize / 2;

            // Shield ring + yellow glow (double ring at 2 stacks)
            if (gameState.shieldCount > 0) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(playerX, owlCenterY, playerSize/2 + 5, 0, Math.PI * 2);
                ctx.stroke();
                if (gameState.shieldCount >= 2) {
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(playerX, owlCenterY, playerSize/2 + 12, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Magnet ring + red glow (overrides shield if both active)
            if (gameState.magnet) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff0000';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(playerX, owlCenterY, playerSize/2 + 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw player sprite - glow carries over from powerup if active
            const frameIndex = Math.floor(gameState.playerAnimFrame) % 6 + 1;
            let spriteImg;

            if (gameState.isWalking) {
                spriteImg = assets.images[`walk${frameIndex}`];
            } else {
                spriteImg = assets.images[`jump${frameIndex}`];
            }

            if (spriteImg && spriteImg.complete) {
                ctx.drawImage(spriteImg, playerX - playerSize/2, playerY - playerSize, playerSize, playerSize);
            } else {
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(playerX, playerY, playerSize/2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Kill shadow state completely
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.restore();
        }

        function drawUI() {
            ctx.save();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#0ff';
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'left';

            // Score
            ctx.fillText(`SCORE: ${gameState.score}`, 10, 30);

            // (combo display removed)

            // (close call display removed)

            // Coin rain — handled in spawnObject, no extra visual needed here

            // Lives display - owl faces, no glow/shadow
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            const livesX = canvas.width - 45;
            const livesY = 45;
            const lifeSize = 65;
            const lifeSpacing = 55;
            const owlLifeImg = assets.images.look1;

            for (let i = 0; i < gameState.lives; i++) {
                const lx = livesX - (i * lifeSpacing) - lifeSize;
                const ly = livesY - 5;
                if (owlLifeImg && owlLifeImg.complete) {
                    const sw = owlLifeImg.naturalWidth;
                    const sh = owlLifeImg.naturalHeight;
                    const cropX = sw * 0.05;
                    const cropY = 0;
                    const cropW = sw * 0.9;
                    const cropH = sh * 0.58;
                    const drawH = lifeSize * (cropH / cropW);
                    ctx.drawImage(owlLifeImg, cropX, cropY, cropW, cropH, lx, ly, lifeSize, drawH);
                }
            }

            // Compromise message - big banner style
            if (gameState.compromiseMessageLife > 0) {
                const alpha = Math.min(1, gameState.compromiseMessageLife / 500);  // Fade out
                ctx.save();
                ctx.globalAlpha = alpha;

                // Semi-transparent black background banner
                const bannerY = canvas.height * 0.3;
                const bannerHeight = 50;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, bannerY - bannerHeight/2, canvas.width, bannerHeight);

                // Red border on banner
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, bannerY - bannerHeight/2, canvas.width, bannerHeight);

                // White text — auto-size to fit screen width
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                let fontSize = 16;
                ctx.font = `${fontSize}px "Press Start 2P"`;
                while (ctx.measureText(gameState.compromiseMessage).width > canvas.width - 20 && fontSize > 8) {
                    fontSize -= 1;
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                }
                ctx.fillText(gameState.compromiseMessage, canvas.width / 2, bannerY + fontSize/2);

                ctx.restore();
            }

            ctx.restore();
        }

        function drawTitleScreen() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw title image
            if (assets.images.title.complete) {
                ctx.drawImage(assets.images.title, 0, 0, canvas.width, canvas.height);
            }

            // Animated owl sprite (look_1 through look_6)
            const lookFrames = [assets.images.look1, assets.images.look2, assets.images.look3, assets.images.look4, assets.images.look5, assets.images.look6];
            const frameIdx = Math.floor(Date.now() / 150) % 6;
            const owlFrame = lookFrames[frameIdx];
            if (owlFrame && owlFrame.complete) {
                const owlSize = canvas.width * 0.3;
                const owlX = canvas.width / 2 - owlSize / 2;
                const owlY = canvas.height * 0.42;
                ctx.drawImage(owlFrame, owlX, owlY, owlSize, owlSize);
            }

            // Tap to start below owl — only show when audio is ready
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#0ff';
            const pulseA = 0.5 + 0.5 * Math.sin(Date.now() / 300);
            ctx.globalAlpha = pulseA;
            ctx.fillText('TAP TO START', canvas.width / 2, canvas.height * 0.68);
            ctx.globalAlpha = 1;

            // How to play button (left side of bottom)
            ctx.fillStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('HOW TO PLAY', canvas.width * 0.25, canvas.height * 0.78);

            // High scores button (right side of bottom)
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.fillText('HIGH SCORES', canvas.width * 0.75, canvas.height * 0.78);
        }

        function drawHowToPlay() {
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const s = Math.min(canvas.width, canvas.height) * 0.035; // responsive font base

            // Title
            ctx.fillStyle = '#0ff';
            ctx.font = `bold ${Math.round(s * 1.4)}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0ff';
            ctx.fillText('HOW TO PLAY', cx, s * 2.5);

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // Instructions with game sprites
            const iconSize = Math.round(s * 2.2);
            const startY = canvas.height * 0.14;
            const lineH = canvas.height * 0.085;
            const iconX = canvas.width * 0.15;
            const textX = canvas.width * 0.58;

            const lines = [
                { img: null, emoji: '👆', color: '#00ff88', text: 'HOLD to walk' },
                { img: null, emoji: '✋', color: '#00ff88', text: 'RELEASE to jump' },
                { img: assets.images.coinSprite, color: '#ffd700', text: 'Collect ETH' },
                { img: assets.images.drainer, color: '#ff4444', text: 'Dodge drainers' },
                { img: null, emoji: '🛡️', color: '#ffd700', text: 'Shield blocks' },
                { img: null, emoji: '🧲', color: '#ff6600', text: 'Magnet pulls' },
                { img: null, emoji: '🌧️', color: '#00ffcc', text: 'Coin rain!' },
                { img: 'owlHead', color: '#ff6688', text: '3 lives. Go!' },
            ];

            lines.forEach((line, i) => {
                const y = startY + i * lineH;
                // Draw sprite or emoji — owl head uses cropped look1
                if (line.img === 'owlHead' && assets.images.look1.complete) {
                    // Same crop as in-game lives HUD
                    const src = assets.images.look1;
                    const sw = src.naturalWidth, sh = src.naturalHeight;
                    const cropX = sw * 0.05, cropY = 0;
                    const cropW = sw * 0.9, cropH = sh * 0.58;
                    const headSize = iconSize * 2.112;
                    const drawH = headSize * (cropH / cropW);
                    ctx.drawImage(src, cropX, cropY, cropW, cropH,
                        iconX - headSize/2 + 2, y - drawH * 0.85 - 9, headSize, drawH);
                } else if (line.img && line.img.complete) {
                    ctx.drawImage(line.img, iconX - iconSize/2, y - iconSize * 0.6, iconSize, iconSize);
                } else if (line.emoji) {
                    ctx.font = `${Math.round(iconSize * 0.8)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(line.emoji, iconX, y + iconSize * 0.15);
                }
                // Text
                ctx.font = `${Math.round(s * 0.85)}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.fillStyle = line.color;
                ctx.fillText(line.text, textX, y);
            });

            // Tap to start — raised higher
            ctx.fillStyle = '#0ff';
            ctx.font = `${Math.round(s)}px "Press Start 2P"`;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#0ff';
            const pulseAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 300);
            ctx.globalAlpha = pulseAlpha;
            ctx.fillText('TAP TO START', cx, canvas.height - s * 6);
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // YOU GOT RUGGED - big glitchy red text
            ctx.fillStyle = '#ff0000';
            ctx.font = '28px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff0000';

            // Glitchy effect
            const glitchOffset = Math.random() * 4 - 2;
            ctx.fillText('YOU GOT', canvas.width / 2 + glitchOffset, canvas.height * 0.25);
            ctx.fillText('RUGGED', canvas.width / 2 - glitchOffset, canvas.height * 0.35);

            // Score
            ctx.fillStyle = '#0ff';
            ctx.font = '20px "Press Start 2P"';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 15;
            ctx.fillText(`SCORE: ${gameState.score}`, canvas.width / 2, canvas.height * 0.5);

            // New high score
            if (isHighScore(gameState.score)) {
                ctx.fillStyle = '#ffd700';
                ctx.font = '16px "Press Start 2P"';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, canvas.height * 0.6);
            }

            // Tap to continue
            ctx.fillStyle = '#00ff00';
            ctx.font = '14px "Press Start 2P"';
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.fillText('TAP TO CONTINUE', canvas.width / 2, canvas.height * 0.75);
        }

        function drawHighScores() {
            // Dark cyberpunk background
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title with underline
            ctx.fillStyle = '#0ff';
            ctx.font = '20px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0ff';
            ctx.fillText('GLOBAL HIGH SCORES', canvas.width / 2, 50);

            // Underline
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.2, 60);
            ctx.lineTo(canvas.width * 0.8, 60);
            ctx.stroke();

            // High score entries - each in DIFFERENT COLOR
            ctx.font = '14px "Press Start 2P"';
            gameState.highScores.forEach((entry, i) => {
                const y = 100 + i * 35;
                // Highlight new high score
                if (i === gameState.newHighScoreIndex) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(0, y - 20, canvas.width, 30);
                }

                // All entries bright yellow
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 8;

                // Rank number
                ctx.textAlign = 'left';
                ctx.fillText(`${i + 1}.`, 30, y);

                // Initials
                ctx.fillText(entry.initials, 80, y);

                // Score
                ctx.textAlign = 'right';
                ctx.fillText(entry.score.toString(), canvas.width - 30, y);
            });

            // Back button
            ctx.fillStyle = '#ff0000';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff0000';
            ctx.fillText('TAP TO RETURN', canvas.width / 2, canvas.height - 30);
        }

        function drawEnterInitials() {
            // Dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = '18px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffd700';
            ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, 80);

            // Score
            ctx.fillStyle = '#0ff';
            ctx.font = '16px "Press Start 2P"';
            ctx.shadowColor = '#0ff';
            ctx.fillText(`SCORE: ${gameState.score}`, canvas.width / 2, 120);

            // Instructions
            ctx.fillStyle = '#fff';
            ctx.font = '10px "Press Start 2P"';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#fff';
            ctx.fillText('TAP LETTERS TO CYCLE A-Z', canvas.width / 2, 160);

            // Draw three large letters (tap each to cycle)
            const letterSpacing = 80;
            const startX = canvas.width / 2 - letterSpacing;
            const letterY = 240;

            initialsInput.blinkTimer += 16;
            const blink = Math.floor(initialsInput.blinkTimer / 500) % 2 === 0;

            for (let i = 0; i < 3; i++) {
                const x = startX + i * letterSpacing;

                // Box for letter — all bright yellow
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffff00';
                ctx.strokeRect(x - 30, letterY - 45, 60, 60);

                // Letter — bright yellow with glow
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffff00';
                ctx.font = '36px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(initialsInput.letters[i], x, letterY);
            }

            // SUBMIT button (green)
            const submitY = 340;
            ctx.fillStyle = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff00';
            ctx.fillRect(canvas.width / 2 - 100, submitY, 200, 50);

            ctx.fillStyle = '#000';
            ctx.font = '14px "Press Start 2P"';
            ctx.shadowBlur = 0;
            ctx.fillText('SUBMIT', canvas.width / 2, submitY + 32);
        }

        // ==========================================
        // GAME LOOP
        // ==========================================

        let lastTime = performance.now();

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Apply screen shake
            if (gameState.screenShake > 0) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
                gameState.screenShake *= 0.9;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            switch (currentState) {
                case GAME_STATE.TITLE:
                    drawTitleScreen();
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    drawHowToPlay();
                    break;

                case GAME_STATE.PLAYING:
                    // Update physics
                    updatePhysics(deltaTime);

                    // Animation speed based on state
                    let animRate;
                    if (gameState.isWalking) {
                        animRate = deltaTime * 0.01;  // Walk: ~10fps
                    } else if (!gameState.grounded) {
                        animRate = deltaTime * 0.008;  // Jumping: ~8fps
                    } else {
                        animRate = deltaTime * 0.003;  // Idle bounce: slow gentle
                    }
                    gameState.playerAnimFrame += animRate;

                    updateGameSpeed(deltaTime);
                    spawnObject();

                    gameState.objects.forEach(obj => obj.update(deltaTime));
                    checkCollisions();

                    if (gameState.magnet) {
                        gameState.magnetTimer -= deltaTime;
                        if (gameState.magnetTimer <= 0) {
                            gameState.magnet = false;
                        }
                    }

                    // Draw
                    drawBackground();
                    gameState.objects.forEach(obj => obj.draw());
                    drawPlayer();

                    // Last life intensity - subtle red vignette pulse
                    if (gameState.lives === 1) {
                        const pulseAlpha = 0.06 + 0.04 * Math.sin(Date.now() / 400);
                        const vGrad = ctx.createRadialGradient(
                            canvas.width/2, canvas.height * PHYSICS.GAME_AREA_RATIO / 2, canvas.width * 0.3,
                            canvas.width/2, canvas.height * PHYSICS.GAME_AREA_RATIO / 2, canvas.width * 0.8
                        );
                        vGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
                        vGrad.addColorStop(1, `rgba(255, 0, 0, ${pulseAlpha})`);
                        ctx.fillStyle = vGrad;
                        ctx.fillRect(0, 0, canvas.width, canvas.height * PHYSICS.GAME_AREA_RATIO);
                    }

                    // (milestone flash removed)

                    // Speed wind lines when going fast
                    if (gameState.bgSpeed > 10) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.lineWidth = 1;
                        const t = Date.now();
                        for (let i = 0; i < 4; i++) {
                            const ly = ((i * 173 + t * 0.03) % (canvas.height * 0.7)) + 20;
                            const lx = (t * (0.8 + i * 0.2)) % canvas.width;
                            ctx.beginPath();
                            ctx.moveTo(lx, ly);
                            ctx.lineTo(lx - 60 - gameState.bgSpeed * 4, ly);
                            ctx.stroke();
                        }
                    }

                    drawUI();
                    break;

                case GAME_STATE.GAME_OVER:
                    drawGameOverScreen();
                    break;

                case GAME_STATE.HIGH_SCORES:
                    drawHighScores();
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    drawEnterInitials();
                    break;
            }

            if (gameState.screenShake > 0) {
                ctx.restore();
            }

            requestAnimationFrame(gameLoop);
        }

        // ==========================================
        // INPUT HANDLING - CRITICAL: Hold to walk, Release to jump
        // ==========================================

        let touchActive = false;

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            enableAudio();

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            switch (currentState) {
                case GAME_STATE.TITLE:
                    if (y > canvas.height * 0.7 && x < canvas.width * 0.5) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else if (y > canvas.height * 0.7 && x >= canvas.width * 0.5) {
                        currentState = GAME_STATE.HIGH_SCORES;
                    } else if (!localStorage.getItem('etherDashTutorialSeen')) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else {
                        resetGame();
                        currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    }
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    localStorage.setItem('etherDashTutorialSeen', '1');
                    resetGame();
                    currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    break;

                case GAME_STATE.PLAYING:
                    // HOLD = WALK
                    startHolding();
                    touchActive = true;
                    break;

                case GAME_STATE.GAME_OVER:
                    if (isHighScore(gameState.score)) {
                        initialsInput = { letters: ['A', 'A', 'A'], currentIndex: 0, blinkTimer: 0 };
                        currentState = GAME_STATE.ENTER_INITIALS;
                    } else {
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;

                case GAME_STATE.HIGH_SCORES:
                    currentState = GAME_STATE.TITLE;
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    // Check which letter was tapped
                    const letterSpacing = 80;
                    const startX = canvas.width / 2 - letterSpacing;
                    const letterY = 240;

                    for (let i = 0; i < 3; i++) {
                        const lx = startX + i * letterSpacing;
                        if (x > lx - 30 && x < lx + 30 && y > letterY - 45 && y < letterY + 15) {
                            cycleInitialLetter(i);
                            break;
                        }
                    }

                    // Check submit button
                    const submitY = 340;
                    if (y > submitY && y < submitY + 50 && x > canvas.width / 2 - 100 && x < canvas.width / 2 + 100) {
                        const initials = initialsInput.letters.join('');
                        addHighScore(initials, gameState.score);
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();

            // RELEASE = JUMP
            if (currentState === GAME_STATE.PLAYING && touchActive) {
                releaseHolding();
                touchActive = false;
            }
        }, { passive: false });

        // Mouse events for desktop testing
        canvas.addEventListener('mousedown', (e) => {
            enableAudio();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            switch (currentState) {
                case GAME_STATE.TITLE:
                    if (y > canvas.height * 0.7 && x < canvas.width * 0.5) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else if (y > canvas.height * 0.7 && x >= canvas.width * 0.5) {
                        currentState = GAME_STATE.HIGH_SCORES;
                    } else if (!localStorage.getItem('etherDashTutorialSeen')) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else {
                        resetGame();
                        currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    }
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    localStorage.setItem('etherDashTutorialSeen', '1');
                    resetGame();
                    currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    break;

                case GAME_STATE.PLAYING:
                    startHolding();
                    touchActive = true;
                    break;

                case GAME_STATE.GAME_OVER:
                    if (isHighScore(gameState.score)) {
                        initialsInput = { letters: ['A', 'A', 'A'], currentIndex: 0, blinkTimer: 0 };
                        currentState = GAME_STATE.ENTER_INITIALS;
                    } else {
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;

                case GAME_STATE.HIGH_SCORES:
                    currentState = GAME_STATE.TITLE;
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    const letterSpacing = 80;
                    const startX = canvas.width / 2 - letterSpacing;
                    const letterY = 240;

                    for (let i = 0; i < 3; i++) {
                        const lx = startX + i * letterSpacing;
                        if (x > lx - 30 && x < lx + 30 && y > letterY - 45 && y < letterY + 15) {
                            cycleInitialLetter(i);
                            break;
                        }
                    }

                    const submitY = 340;
                    if (y > submitY && y < submitY + 50 && x > canvas.width / 2 - 100 && x < canvas.width / 2 + 100) {
                        const initials = initialsInput.letters.join('');
                        addHighScore(initials, gameState.score);
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (currentState === GAME_STATE.PLAYING && touchActive) {
                releaseHolding();
                touchActive = false;
            }
        });

        // Keyboard controls for desktop testing
        let keyHeld = false;
        document.addEventListener('keydown', (e) => {
            if (currentState === GAME_STATE.PLAYING) {
                if ((e.key === ' ' || e.key === 'ArrowDown' || e.key === 's') && !keyHeld) {
                    e.preventDefault();
                    startHolding();
                    keyHeld = true;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (currentState === GAME_STATE.PLAYING) {
                if (e.key === ' ' || e.key === 'ArrowDown' || e.key === 's') {
                    e.preventDefault();
                    releaseHolding();
                    keyHeld = false;
                }
            }
        });

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
