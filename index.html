<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>Ether Dash</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background: #000;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #gameContainer {
            width: 100vw;
            height: 100dvh; /* Use dynamic viewport height for mobile Safari */
            display: flex;
            justify-content: center;
            align-items: center; /* Center canvas vertically on all phones */
            background: #000;
        }

        canvas {
            display: block;
            background: #1a0033;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #0ff;
            font-size: 12px;
            z-index: 1000;
        }

        .loading-text {
            margin-top: 20px;
        }

        .loading-bar {
            width: 200px;
            height: 20px;
            border: 2px solid #0ff;
            margin-top: 10px;
            position: relative;
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ff, #f0f);
            width: 0%;
            transition: width 0.3s;
        }

        .glow {
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="loadingScreen">
        <div class="glow" style="font-size: 20px;">ETHER DASH</div>
        <div class="loading-text">Loading...</div>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
    </div>

    <script>
        // ==========================================
        // ETHER DASH - Mobile Runner Game
        // ==========================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingFill = document.getElementById('loadingFill');

        // Canvas setup for portrait mobile - account for Safari UI
        function resizeCanvas() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Leave room for Safari's UI bars
            canvas.width = windowWidth;
            canvas.height = windowHeight * 0.95; // Use 95% to avoid Safari UI overlap
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==========================================
        // GAME STATE
        // ==========================================

        const GAME_STATE = {
            LOADING: 'loading',
            TITLE: 'title',
            HOW_TO_PLAY: 'howToPlay',
            PLAYING: 'playing',
            GAME_OVER: 'gameOver',
            HIGH_SCORES: 'highScores',
            ENTER_INITIALS: 'enterInitials'
        };

        let currentState = GAME_STATE.LOADING;

        // ==========================================
        // ASSET LOADING
        // ==========================================

        const assets = {
            images: {},
            audio: {},
            loaded: 0,
            total: 0
        };

        const imagesToLoad = {
            background: 'Background.png',
            title: 'Title.jpg',
            ethCoin: 'EthCoin.png',
            drainer: 'Drainer.png',
            drainer2: 'Drainer2.png',
            coinSprite: 'sprites/coin.png',
            cashoutSprite: 'sprites/cashout.png',
            jump1: 'sprites/Jump 1.png',
            jump2: 'sprites/Jump 2.png',
            jump3: 'sprites/Jump 3.png',
            jump4: 'sprites/Jump 4.png',
            jump5: 'sprites/Jump 5.png',
            jump6: 'sprites/Jump 6.png',
            walk1: 'sprites/walk_1.png',
            walk2: 'sprites/walk_2.png',
            walk3: 'sprites/walk_3.png',
            walk4: 'sprites/walk_4.png',
            walk5: 'sprites/walk_5.png',
            walk6: 'sprites/walk_6.png',
            look1: 'sprites/look_1.png',
            look2: 'sprites/look_2.png',
            look3: 'sprites/look_3.png',
            look4: 'sprites/look_4.png',
            look5: 'sprites/look_5.png',
            look6: 'sprites/look_6.png'
        };

        const audioToLoad = {
            coin: 'audio/Coin.mp3',
            drain: 'audio/Drain.mp3',
            jump: 'audio/Jump.mp3',
            money: 'audio/Money.mp3',
            bgMusic: 'audio/Ether M1.mp3',
            hiScoreMusic: 'audio/HiS.mp3',
            textSound: 'audio/Text.mp3'
        };

        assets.total = Object.keys(imagesToLoad).length + Object.keys(audioToLoad).length;

        function updateLoadingBar() {
            const percent = (assets.loaded / assets.total) * 100;
            loadingFill.style.width = percent + '%';

            if (assets.loaded === assets.total) {
                
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    currentState = GAME_STATE.TITLE;
                }, 500);
            }
        }

        // Load images
        Object.keys(imagesToLoad).forEach(key => {
            const img = new Image();
            img.onload = () => {
                assets.loaded++;
                updateLoadingBar();
            };
            img.onerror = () => {
                console.warn(`Failed to load image: ${imagesToLoad[key]}`);
                assets.loaded++;
                updateLoadingBar();
            };
            img.src = imagesToLoad[key];
            assets.images[key] = img;
        });

        // Load audio
        Object.keys(audioToLoad).forEach(key => {
            const audio = new Audio();
            audio.oncanplaythrough = () => {
                assets.loaded++;
                updateLoadingBar();
            };
            audio.onerror = () => {
                console.warn(`Failed to load audio: ${audioToLoad[key]}`);
                assets.loaded++;
                updateLoadingBar();
            };
            audio.src = audioToLoad[key];
            audio.load();
            assets.audio[key] = audio;
        });

        // Audio system - Web Audio API for sound effects
        let audioEnabled = false;
        let musicStarted = false;
        let audioCtx = null;
        const audioBuffers = {};
        const audioRawData = {};

        // Pre-fetch audio files immediately (no user gesture needed for fetch)
        const soundFiles = {
            jump: 'audio/Jump.mp3',
            coin: 'audio/Coin.mp3',
            drain: 'audio/Drain.mp3',
            money: 'audio/Money.mp3',
            textSound: 'audio/Text.mp3'
        };
        const fetchPromises = [];
        for (const [name, url] of Object.entries(soundFiles)) {
            const p = fetch(url).then(r => r.arrayBuffer()).then(buf => {
                audioRawData[name] = buf;
            }).catch(() => {});
            fetchPromises.push(p);
        }
        const allFetched = Promise.all(fetchPromises);

        async function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            await decodeAllPending();
            allFetched.then(() => decodeAllPending());
        }

        async function decodeAllPending() {
            if (!audioCtx) return;
            for (const [name, buf] of Object.entries(audioRawData)) {
                if (!audioBuffers[name]) {
                    try {
                        audioBuffers[name] = await audioCtx.decodeAudioData(buf.slice(0));
                    } catch(e) {
                        console.warn('Failed to decode sound:', name);
                    }
                }
            }
            // Check if all sounds are decoded
            const allDecoded = Object.keys(soundFiles).every(n => audioBuffers[n]);
        }

        function playSound(name) {
            if (!audioEnabled || !audioCtx) return;
            // Force resume if still suspended
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            // Synthesized shield block sound
            if (name === 'shieldBlock') {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.2);
                return;
            }
            if (!audioBuffers[name]) {
                // Try late decode if raw data arrived after initAudio â€” play once ready
                if (audioRawData[name]) {
                    audioCtx.decodeAudioData(audioRawData[name].slice(0)).then(buf => {
                        audioBuffers[name] = buf;
                        const s = audioCtx.createBufferSource();
                        s.buffer = buf;
                        s.connect(audioCtx.destination);
                        s.start(0);
                    }).catch(() => {});
                }
                return;
            }
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffers[name];
            source.connect(audioCtx.destination);
            source.start(0);
        }

        function startMusic() {
            if (!audioEnabled || musicStarted) return;
            const music = assets.audio.bgMusic;
            if (music) {
                music.loop = true;
                music.volume = 0.5;
                music.play().catch(e => console.warn('Music play failed:', e));
                musicStarted = true;
            }
        }

        function enableAudio() {
            if (!audioEnabled) {
                audioEnabled = true;
                // Create AudioContext synchronously in user gesture (Chrome requirement)
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                // No unlock needed â€” spawn delay gives Chrome time to warm up
            }
            // Chrome suspends AudioContext until user gesture â€” MUST resume first
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    decodeAllPending();
                    allFetched.then(() => decodeAllPending());
                });
            } else if (audioCtx) {
                decodeAllPending();
                allFetched.then(() => decodeAllPending());
            }
        }

        // Audio context created on first user gesture (enableAudio), raw files pre-fetched above

        // ==========================================
        // GAME VARIABLES
        // ==========================================

        // Physics constants - matching iOS original
        const PHYSICS = {
            GRAVITY: 0.9,
            JUMP_FORCE: -20,
            GAME_AREA_RATIO: 0.9,  // Top 90% is game area  
            HOLD_ZONE_RATIO: 0.1,  // Bottom 10% is hold zone
            GROUND_Y_RATIO: 0.81,  // Owl feet on railing
            PLAYER_X_RATIO: 0.3,   // Player at 30% from left
            WALK_SPEED_MULTIPLIER: 1,  // Direct speed when walking (applied to base walk speed)
            IDLE_SPEED: 0,  // No scroll when idle â€” owl only moves when you hold
            JUMP_SPEED_MULTIPLIER: 1.0  // Same speed as running
        };

        let gameState = {
            score: 0,
            coinsCollected: 0,  // Track coins separately from score
            lives: 3,  // Lives system
            combo: 0,
            comboMultiplier: 1,
            shieldCount: 0,  // 0=none, 1=single shield, 2=double shield
            invincibleTimer: 0,  // i-frames after taking damage (ms)
            coinRainTimer: 0,  // coin rain powerup duration (ms)
            magnet: false,
            magnetTimer: 0,
            bgScroll: 0,
            bgSpeed: PHYSICS.IDLE_SPEED,
            playerY: 0,  // Actual Y position
            playerVelocityY: 0,  // Vertical velocity
            playerX: 0,  // Fixed X position (30% from left)
            grounded: true,
            isHolding: false,  // CRITICAL: track if player is holding
            isWalking: false,  // Track walking state
            playerAnimFrame: 0,
            playerAnimTimer: 0,
            walkAnimSpeed: 0.07,  // timePerFrame for walk
            jumpAnimSpeed: 0.1,   // timePerFrame for jump
            objects: [],
            particles: [],
            screenShake: 0,
            lastSpawnTime: 0,
            spawnInterval: 400,  // Fast spawns â€” screen full of coins
            gameTime: 0,
            drainersEnabled: false,
            highScores: [],
            lastDrainerX: -1000,
            milestoneReached: 0,
            newHighScoreIndex: -1,  // For highlighting new score
            compromiseMessage: '',  // Current compromise message
            compromiseMessageLife: 0,  // Life timer for message
            milestoneFlash: 0  // White flash for milestone celebrations
        };

        // Get ground level Y position
        function getGroundY() {
            return canvas.height * PHYSICS.GROUND_Y_RATIO;
        }

        // Get player size (larger than before - 2.1x scale like original)
        function getPlayerSize() {
            return Math.min(canvas.height * 0.13, 120);  // Bigger owl
        }

        // ==========================================
        // HIGH SCORE SYSTEM
        // ==========================================

        const HIGH_SCORE_COLORS = [
            '#ff0000',  // red
            '#00ff00',  // green
            '#ffff00',  // yellow
            '#0000ff',  // blue
            '#00ffff',  // cyan
            '#ff00ff',  // magenta
            '#ff8800',  // orange
            '#8800ff',  // purple
            '#884400',  // brown
            '#aaaaaa'   // lightGray
        ];

        const LEADERBOARD_URL = 'https://tomatobird.xyz/api/scores';

        function loadHighScores() {
            // Load local scores first (instant)
            const saved = localStorage.getItem('etherDashHighScores');
            if (saved) {
                gameState.highScores = JSON.parse(saved);
            } else {
                gameState.highScores = [];
            }

            // Then fetch global scores and merge
            fetch(LEADERBOARD_URL)
                .then(r => r.json())
                .then(globalScores => {
                    if (Array.isArray(globalScores)) {
                        // Merge local and global, dedupe, keep top 10
                        const all = [...gameState.highScores, ...globalScores];
                        const seen = new Set();
                        const unique = all.filter(e => {
                            const key = e.initials + ':' + e.score;
                            if (seen.has(key)) return false;
                            seen.add(key);
                            return true;
                        });
                        unique.sort((a, b) => b.score - a.score);
                        gameState.highScores = unique.slice(0, 10);
                        saveHighScores();
                    }
                })
                .catch(() => {}); // silently fail â€” local scores still work
        }

        function saveHighScores() {
            localStorage.setItem('etherDashHighScores', JSON.stringify(gameState.highScores));
        }

        function addHighScore(initials, score) {
            gameState.highScores.push({ initials, score, date: Date.now() });
            gameState.highScores.sort((a, b) => b.score - a.score);
            gameState.highScores = gameState.highScores.slice(0, 10);

            // Find the index of the new score
            gameState.newHighScoreIndex = gameState.highScores.findIndex(entry =>
                entry.initials === initials && entry.score === score
            );

            saveHighScores();

            // Submit to global leaderboard (atomic â€” server handles merge)
            fetch(LEADERBOARD_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ initials, score })
            })
            .then(r => r.json())
            .then(data => {
                if (data.scores) {
                    gameState.highScores = data.scores;
                    saveHighScores();
                }
            })
            .catch(() => {});
        }

        function isHighScore(score) {
            return gameState.highScores.length < 10 || score > gameState.highScores[gameState.highScores.length - 1].score;
        }

        loadHighScores();

        // ==========================================
        // INITIALS INPUT SYSTEM
        // ==========================================

        let initialsInput = {
            letters: ['A', 'A', 'A'],
            currentIndex: 0,
            blinkTimer: 0
        };

        function cycleInitialLetter(index) {
            const current = initialsInput.letters[index];
            const charCode = current.charCodeAt(0);
            if (charCode >= 90) {  // Z wraps to A
                initialsInput.letters[index] = 'A';
            } else {
                initialsInput.letters[index] = String.fromCharCode(charCode + 1);
            }
            playSound('textSound');
        }

        // Music management
        function stopMusic() {
            musicStarted = false;
            const music = assets.audio.bgMusic;
            if (music) { music.pause(); music.currentTime = 0; }
            const hsMusic = assets.audio.hiScoreMusic;
            if (hsMusic) { hsMusic.pause(); hsMusic.currentTime = 0; }
        }

        // Pause all audio when tab/app is hidden (switching apps, locking phone)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const music = assets.audio.bgMusic;
                if (music && !music.paused) music.pause();
                const hsMusic = assets.audio.hiScoreMusic;
                if (hsMusic && !hsMusic.paused) hsMusic.pause();
                if (audioCtx && audioCtx.state === 'running') audioCtx.suspend();
            } else {
                // Resume when coming back
                if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
                if (currentState === GAME_STATE.PLAYING && musicStarted) {
                    const music = assets.audio.bgMusic;
                    if (music && music.paused) music.play().catch(() => {});
                } else if (currentState === GAME_STATE.GAME_OVER || currentState === GAME_STATE.HIGH_SCORES || currentState === GAME_STATE.ENTER_INITIALS) {
                    const hsMusic = assets.audio.hiScoreMusic;
                    if (hsMusic && hsMusic.paused) hsMusic.play().catch(() => {});
                }
            }
        });

        function playHiScoreMusic() {
            stopMusic();
            if (!audioEnabled) return;
            const music = assets.audio.hiScoreMusic;
            if (music) {
                music.loop = true;
                music.volume = 0.5;
                music.play().catch(() => {});
            }
        }

        // ==========================================
        // GAME OBJECTS
        // ==========================================

        class GameObject {
            constructor(type, heightType, x) {
                this.type = type;
                this.heightType = heightType;
                this.x = x;
                this.y = this.getYPosition(heightType);
                // Drainers ~10% bigger than coins
                const sz = (type === 'drainer') ? 46 : 42;
                this.width = sz;
                this.height = sz;
                this.collected = false;
                this.pulseTime = 0;
                this.bobOffset = 0;
                this.falling = false;  // rain coins fall straight down
                this.fallSpeed = 0;
            }

            getYPosition(heightType) {
                const groundY = getGroundY();
                const playerSize = getPlayerSize();
                if (heightType === 'ground') {
                    return groundY - playerSize * 0.6;  // Coin at owl body height
                } else if (heightType === 'lower') {
                    return groundY - canvas.height * 0.2;  // Low jump
                } else {  // 'upper'
                    return groundY - canvas.height * 0.35;  // High jump
                }
            }

            update(deltaTime) {
                // Rain coins fall down AND scroll left with the background
                if (this.falling) {
                    this.y += this.fallSpeed * (deltaTime / 16);
                    let speed = gameState.bgSpeed;
                    if (!gameState.grounded) speed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
                    this.x -= speed;
                    this.pulseTime += deltaTime;
                    this.bobOffset = 0;
                    // Magnet pulls rain coins too
                    if (gameState.magnet && this.type === 'coin') {
                        const dx = gameState.playerX - this.x;
                        const dy = gameState.playerY - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < 350) {
                            const pullStrength = 10 + (350 - distance) * 0.03;
                            this.x += (dx / distance) * pullStrength;
                            this.y += (dy / distance) * pullStrength;
                        }
                    }
                    return;
                }

                let speed = gameState.bgSpeed;

                // Jump moves forward - objects scroll faster when in air
                if (!gameState.grounded) {
                    speed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
                }

                this.x -= speed;
                this.pulseTime += deltaTime;

                // Powerups float gently, coins and drainers stay still
                if (this.type !== 'drainer' && this.type !== 'coin') {
                    this.bobOffset = Math.sin(this.pulseTime / 400) * 5;
                } else {
                    this.bobOffset = 0;
                }

                // Magnet pull - only affects coins, not drainers
                // Magnet pull â€” stronger, wider range
                if (gameState.magnet && this.type === 'coin') {
                    const playerX = gameState.playerX;
                    const playerY = gameState.playerY;
                    const dx = playerX - this.x;
                    const dy = playerY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 350) {
                        const pullStrength = 10 + (350 - distance) * 0.03;
                        this.x += (dx / distance) * pullStrength;
                        this.y += (dy / distance) * pullStrength;
                    }
                }

                // (all drainers same size now)
            }

            draw() {
                ctx.save();
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';

                const drawX = this.x;
                const drawY = this.y - this.height / 2 + this.bobOffset;

                // Draw based on type (no shadowBlur for performance)
                switch (this.type) {
                    case 'coin':
                        if (assets.images.coinSprite.complete) {
                            // Magnet trail effect
                            if (gameState.magnet) {
                                ctx.globalAlpha = 0.15;
                                ctx.drawImage(assets.images.coinSprite, drawX - this.width/2 + 16, drawY, this.width, this.height);
                                ctx.globalAlpha = 0.3;
                                ctx.drawImage(assets.images.coinSprite, drawX - this.width/2 + 8, drawY, this.width, this.height);
                                ctx.globalAlpha = 1;
                            }
                            ctx.drawImage(assets.images.coinSprite, drawX - this.width/2, drawY, this.width, this.height);
                        }
                        break;
                    case 'drainer':
                        // Big drainers use drainer2 sprite
                        if (assets.images.drainer.complete) {
                            ctx.drawImage(assets.images.drainer, drawX - this.width/2, drawY, this.width, this.height);
                        }
                        break;
                    case 'extraLife':
                    case 'shield':
                    case 'magnet':
                    case 'coinRain':
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ffffff';
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        const emojiMap = { extraLife: 'â¤ï¸', shield: 'ðŸ›¡ï¸', magnet: 'ðŸ§²', coinRain: 'ðŸŒ§ï¸' };
                        ctx.fillText(emojiMap[this.type], drawX, drawY + this.height/2 + 12);
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        break;
                }

                ctx.restore();
            }

            isOffScreen() {
                if (this.falling) {
                    return this.x < -this.width || this.y > canvas.height * PHYSICS.GAME_AREA_RATIO;
                }
                return this.x < -this.width;
            }

            // Bounding box collision detection
            collidesWith(x, y, width, height) {
                // Tighter hitbox â€” 65% of visual size for precise feel
                const margin = this.width * 0.175;
                const objLeft = this.x - this.width / 2 + margin;
                const objRight = this.x + this.width / 2 - margin;
                const objTop = this.y - this.height / 2 + margin + this.bobOffset;
                const objBottom = this.y + this.height / 2 - margin + this.bobOffset;

                const playerLeft = x;
                const playerRight = x + width;
                const playerTop = y;
                const playerBottom = y + height;

                return objLeft < playerRight &&
                       objRight > playerLeft &&
                       objTop < playerBottom &&
                       objBottom > playerTop;
            }
        }


        // ==========================================
        // GAME LOGIC
        // ==========================================

        function resetGame() {
            gameState.score = 0;
            gameState.coinsCollected = 0;
            gameState.lives = 3;
            gameState.combo = 0;
            gameState.comboMultiplier = 1;
            gameState.shieldCount = 0;
            gameState.invincibleTimer = 0;
            gameState.coinRainTimer = 0;
            gameState.magnet = false;
            gameState.magnetTimer = 0;
            gameState.speedBoost = false;
            gameState.speedBoostTimer = 0;
            gameState.bgScroll = 0;
            gameState.bgSpeed = 0;
            gameState.walkSpeedBonus = 0;
            gameState.playerY = getGroundY();
            gameState.playerVelocityY = 0;
            gameState.playerX = canvas.width * PHYSICS.PLAYER_X_RATIO;
            gameState.grounded = true;
            gameState.isHolding = false;
            gameState.isWalking = false;
            gameState.objects = [];
            gameState.floatingTexts = [];
            gameState.particles = [];
            gameState.screenShake = 0;
            gameState.lastSpawnTime = 0;
            gameState.spawnInterval = 400;
            gameState.gameTime = 0;
            gameState.drainersEnabled = false;
            gameState.milestoneReached = 0;
            gameState.lastDrainerX = -1000;
            gameState.newHighScoreIndex = -1;
            gameState.compromiseMessage = '';
            gameState.compromiseMessageLife = 0;
            gameState.closeCallMessage = '';
            gameState.closeCallLife = 0;
            gameState.milestoneFlash = 0;
            gameState.lastMilestone = 0;
        }

        function spawnObject() {
            // Delay first spawn so audio has time to warm up
            if (gameState.gameTime < 1500) return;
            const now = Date.now();
            if (now - gameState.lastSpawnTime < gameState.spawnInterval) return;

            gameState.lastSpawnTime = now;

            // Coin rain mode: spawn extra coins
            const spawnCount = gameState.coinRainTimer > 0 ? 4 : 2;  // 2 base, 4 during rain

            for (let s = 0; s < spawnCount; s++) {
                // THREE Y positions: ground, lower air, upper air
                const rand = Math.random();
                const heightType = rand < 0.35 ? 'ground' : (rand < 0.7 ? 'lower' : 'upper');

                let type = 'coin';

                // Only first spawn per tick can be drainer/powerup (rest are coins)
                if (s === 0) {
                    // Drainer logic - 5% for first 15 coins, then ramps 15%â†’35% over ~90s
                    const gameTimeSec = gameState.gameTime / 1000;
                    if (gameState.drainersEnabled) {
                        const drainerProb = gameState.coinsCollected < 15
                            ? 0.05
                            : Math.min(0.35, 0.15 + (gameTimeSec / 90) * 0.20);
                        if (Math.random() < drainerProb) {
                            type = 'drainer';
                        }
                    }

                    // Powerup logic - more frequent now
                    const powerupChance = Math.min(0.18, 0.08 + gameTimeSec / 400);
                    if (type === 'coin' && Math.random() < powerupChance) {
                        const r = Math.random();
                        if (r < 0.35) type = 'shield';
                        else if (r < 0.7) type = 'magnet';
                        else type = 'coinRain';
                    }

                    // Extra life â€” very rare, only when damaged
                    if (type === 'coin' && Math.random() < 0.008 && gameState.lives < 3) {
                        type = 'extraLife';
                    }
                }

                // Check for overlap with existing objects near spawn point
                const xOffset = canvas.width + 100 + s * 80;  // stagger spawns
                const newObj = new GameObject(type, heightType, xOffset);

                const overlaps = gameState.objects.some(obj =>
                    Math.abs(obj.x - newObj.x) < 50 && Math.abs(obj.y - newObj.y) < 50
                );
                if (!overlaps && gameState.objects.length < 25) {
                    gameState.objects.push(newObj);
                }
            }

            // Coin rain: dense shower from top-right, angled toward player
            if (gameState.coinRainTimer > 0) {
                const rainCount = 4;  // 4 rain coins per spawn tick
                for (let r = 0; r < rainCount; r++) {
                    const rainCoin = new GameObject('coin', 'upper', 0);
                    // Spawn off-screen right so player runs into the rain
                    rainCoin.x = canvas.width + Math.random() * canvas.width * 0.5;
                    rainCoin.y = -20 - Math.random() * 100;
                    rainCoin.falling = true;
                    rainCoin.fallSpeed = 8 + Math.random() * 5;  // fast rain
                    if (gameState.objects.length < 35) {
                        gameState.objects.push(rainCoin);
                    }
                }
            }
        }

        // CRITICAL: New control system - HOLD to walk, RELEASE to jump
        function startHolding() {
            gameState.isHolding = true;

            // If grounded, immediately start walking
            if (gameState.grounded) {
                gameState.isWalking = true;
                gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);  // Faster base speed
            }
        }

        function releaseHolding() {
            gameState.isHolding = false;
            gameState.isWalking = false;

            // RELEASE = JUMP (only if grounded)
            if (gameState.grounded) {
                gameState.playerVelocityY = PHYSICS.JUMP_FORCE;
                gameState.grounded = false;
                // Keep moving during jump â€” maintain walk speed (jump multiplier handled in object update)
                gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);

                // Play jump sound ONLY when jump actually happens
                playSound('jump');
            } else {
                // Released while in air â€” stop when landing
                gameState.bgSpeed = 0;
            }
        }

        function updatePhysics(deltaTime) {
            // Apply gravity
            gameState.playerVelocityY += PHYSICS.GRAVITY;

            // Update position
            gameState.playerY += gameState.playerVelocityY;

            // Ground collision
            const groundY = getGroundY();
            if (gameState.playerY >= groundY) {
                gameState.playerY = groundY;
                gameState.playerVelocityY = 0;
                gameState.grounded = true;

                // If player is still holding when landing, start walking again
                if (gameState.isHolding) {
                    gameState.isWalking = true;
                    gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);  // Faster base speed
                } else {
                    // Idle bounce - no walking
                    gameState.isWalking = false;
                    gameState.bgSpeed = 0;
                }
            }

            // Don't go above screen
            if (gameState.playerY < 50) {
                gameState.playerY = 50;
                gameState.playerVelocityY = 0;
            }

            // Background scrolling â€” faster during jump
            let scrollSpeed = gameState.bgSpeed;
            if (!gameState.grounded && scrollSpeed > 0) {
                scrollSpeed *= PHYSICS.JUMP_SPEED_MULTIPLIER;
            }
            gameState.bgScroll += scrollSpeed;
        }

        function updateGameSpeed(deltaTime) {
            gameState.gameTime += deltaTime;

            // Increase difficulty every 15 seconds (smoother ramp)
            if (Math.floor(gameState.gameTime / 15000) > Math.floor((gameState.gameTime - deltaTime) / 15000)) {
                gameState.walkSpeedBonus = (gameState.walkSpeedBonus || 0) + 0.3;
                gameState.spawnInterval = Math.max(300, gameState.spawnInterval - 30);
            }
            // Apply walk speed bonus when walking
            if (gameState.isWalking) {
                gameState.bgSpeed = 7 + (gameState.walkSpeedBonus || 0);  // Faster base speed
            }

            // Drainers enabled from the start
            gameState.drainersEnabled = true;

            // Visual milestones
            if (gameState.score >= 200 && gameState.milestoneReached < 3) {
                gameState.milestoneReached = 3;
            } else if (gameState.score >= 100 && gameState.milestoneReached < 2) {
                gameState.milestoneReached = 2;
            } else if (gameState.score >= 50 && gameState.milestoneReached < 1) {
                gameState.milestoneReached = 1;
            }

            // Update compromise message timer
            if (gameState.compromiseMessageLife > 0) {
                gameState.compromiseMessageLife -= deltaTime;
            }

            // Update invincibility timer
            if (gameState.invincibleTimer > 0) {
                gameState.invincibleTimer -= deltaTime;
            }

            // Update coin rain timer
            if (gameState.coinRainTimer > 0) {
                gameState.coinRainTimer -= deltaTime;
            }
        }

        function checkCollisions() {
            const playerX = gameState.playerX;
            const playerY = gameState.playerY;
            const playerSize = getPlayerSize();

            gameState.objects.forEach((obj, index) => {
                if (obj.collected) return;

                // Position-based bounding box collision - playerY is at feet, sprite extends upward
                // Tighter player hitbox â€” 70% of sprite
                const hitMargin = playerSize * 0.15;
                if (obj.collidesWith(playerX - playerSize/2 + hitMargin, playerY - playerSize + hitMargin, playerSize - hitMargin*2, playerSize - hitMargin*2)) {
                    obj.collected = true;

                    switch (obj.type) {
                        case 'coin':
                            gameState.score += 1;
                            gameState.coinsCollected++;

                            playSound('coin');
                            break;

                        case 'drainer':
                            if (gameState.invincibleTimer > 0) {
                                // i-frames active, ignore hit
                                obj.collected = false;  // don't consume the drainer
                                return;
                            }
                            if (gameState.shieldCount > 0) {
                                gameState.shieldCount--;
                                playSound('shieldBlock');
                            } else {
                                // Lose a life
                                gameState.lives--;
                                gameState.invincibleTimer = 1500;  // 1.5s i-frames after taking damage
                                gameState.combo = 0;
                                gameState.comboMultiplier = 1;
                                gameState.screenShake = 15;
                                playSound('drain');

                                // Random compromise message
                                const messages = [
                                    'Wallet compromised!',
                                    'Seed phrase leaked!',
                                    'Connected to malicious dApp!',
                                    'Approved unlimited spend!',
                                    'Phishing link clicked!',
                                    'Rug pull detected!',
                                    'Private key exposed!',
                                    'Smart contract exploit!'
                                ];
                                gameState.compromiseMessage = messages[Math.floor(Math.random() * messages.length)];
                                gameState.compromiseMessageLife = 1500;  // Show for 1.5 seconds

                                // Check for game over
                                if (gameState.lives <= 0) {
                                    currentState = GAME_STATE.GAME_OVER; stopMusic(); playHiScoreMusic();
                                }
                            }
                            break;

                        case 'shield':
                            gameState.shieldCount = Math.min(gameState.shieldCount + 1, 2);
                            playSound('coin');
                            break;

                        case 'magnet':
                            gameState.magnet = true;
                            gameState.magnetTimer = 4000;
                            playSound('coin');
                            break;

                        case 'coinRain':
                            gameState.coinRainTimer = 5000;  // 5 seconds of coin rain
                            playSound('coin');
                            break;

                        case 'extraLife':
                            gameState.lives = Math.min(3, gameState.lives + 1);
                            playSound('money');
                            gameState.milestoneFlash = 200;
                            break;
                    }
                }

                // (close call removed)
            });

            // Remove collected and off-screen objects
            gameState.objects = gameState.objects.filter(obj => !obj.collected && !obj.isOffScreen());

            // Missed coin tracking (combo removed)
            gameState.objects.forEach(obj => {
                if (false) { // combo removed
                }
            });
        }


        // ==========================================
        // DRAWING FUNCTIONS
        // ==========================================

        function drawBackground() {
            ctx.save();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // Background tint based on milestone
            let tint = '#1a0033';
            if (gameState.milestoneReached >= 3) {
                tint = '#330066';
            } else if (gameState.milestoneReached >= 2) {
                tint = '#220044';
            } else if (gameState.milestoneReached >= 1) {
                tint = '#1a0040';
            }

            ctx.fillStyle = tint;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw scrolling background in top 80% (game area)
            if (assets.images.background.complete) {
                const gameAreaHeight = canvas.height * PHYSICS.GAME_AREA_RATIO;
                const bgOffsetY = 0;
                const bgHeight = gameAreaHeight;
                const bgWidth = assets.images.background.width * (bgHeight / assets.images.background.height);
                const scrollX = -gameState.bgScroll % bgWidth;

                ctx.globalAlpha = 0.7;
                ctx.drawImage(assets.images.background, scrollX, bgOffsetY, bgWidth, bgHeight);
                ctx.drawImage(assets.images.background, scrollX + bgWidth, bgOffsetY, bgWidth, bgHeight);
                ctx.globalAlpha = 1.0;
            }

            // Draw hold zone at bottom 20%
            const holdZoneY = canvas.height * PHYSICS.GAME_AREA_RATIO;
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, holdZoneY, canvas.width, canvas.height * PHYSICS.HOLD_ZONE_RATIO);

            // Hold zone text â€” yellow for visibility
            ctx.fillStyle = '#ffff00';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.isHolding ? 'LET GO TO JUMP' : 'HOLD TO RUN', canvas.width / 2, holdZoneY + canvas.height * PHYSICS.HOLD_ZONE_RATIO / 2);

            ctx.restore();
        }

        function drawPlayer() {
            // Invincibility flashing â€” skip drawing every other 100ms
            if (gameState.invincibleTimer > 0) {
                if (Math.floor(gameState.invincibleTimer / 100) % 2 === 0) {
                    return;  // invisible frame â€” creates flashing effect
                }
            }

            const playerX = gameState.playerX;
            const playerY = gameState.playerY;
            const playerSize = getPlayerSize();

            ctx.save();
            // Always reset shadow first â€” no glow by default
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            const owlCenterY = playerY - playerSize / 2;

            // Shield ring + yellow glow (double ring at 2 stacks)
            if (gameState.shieldCount > 0) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(playerX, owlCenterY, playerSize/2 + 5, 0, Math.PI * 2);
                ctx.stroke();
                if (gameState.shieldCount >= 2) {
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(playerX, owlCenterY, playerSize/2 + 12, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Magnet ring + red glow (overrides shield if both active)
            if (gameState.magnet) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff0000';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(playerX, owlCenterY, playerSize/2 + 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw player sprite - glow carries over from powerup if active
            const frameIndex = Math.floor(gameState.playerAnimFrame) % 6 + 1;
            let spriteImg;

            if (gameState.isWalking) {
                spriteImg = assets.images[`walk${frameIndex}`];
            } else {
                spriteImg = assets.images[`jump${frameIndex}`];
            }

            if (spriteImg && spriteImg.complete) {
                ctx.drawImage(spriteImg, playerX - playerSize/2, playerY - playerSize, playerSize, playerSize);
            } else {
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(playerX, playerY, playerSize/2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Kill shadow state completely
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.restore();
        }

        function drawUI() {
            ctx.save();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#0ff';
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'left';

            // Score
            ctx.fillText(`SCORE: ${gameState.score}`, 15, 35);

            // (combo display removed)

            // (close call display removed)

            // Coin rain â€” handled in spawnObject, no extra visual needed here

            // Lives display - owl faces on same line as score, top right
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            const livesX = canvas.width - 10;  // Right edge
            const livesY = -10;  // Original working position
            const lifeSize = 65;
            const lifeSpacing = 55;
            const owlLifeImg = assets.images.look1;

            for (let i = 0; i < gameState.lives; i++) {
                const lx = livesX - (i * lifeSpacing) - lifeSize;
                const ly = livesY;
                if (owlLifeImg && owlLifeImg.complete) {
                    const sw = owlLifeImg.naturalWidth;
                    const sh = owlLifeImg.naturalHeight;
                    const cropX = sw * 0.05;
                    const cropY = 0;
                    const cropW = sw * 0.9;
                    const cropH = sh * 0.58;
                    const drawH = lifeSize * (cropH / cropW);
                    ctx.drawImage(owlLifeImg, cropX, cropY, cropW, cropH, lx, ly, lifeSize, drawH);
                }
            }

            // Compromise message - big banner style
            if (gameState.compromiseMessageLife > 0) {
                const alpha = Math.min(1, gameState.compromiseMessageLife / 500);  // Fade out
                ctx.save();
                ctx.globalAlpha = alpha;

                // Semi-transparent black background banner
                const bannerY = canvas.height * 0.3;
                const bannerHeight = 50;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, bannerY - bannerHeight/2, canvas.width, bannerHeight);

                // Red border on banner
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, bannerY - bannerHeight/2, canvas.width, bannerHeight);

                // White text â€” auto-size to fit screen width
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                let fontSize = 16;
                ctx.font = `${fontSize}px "Press Start 2P"`;
                while (ctx.measureText(gameState.compromiseMessage).width > canvas.width - 20 && fontSize > 8) {
                    fontSize -= 1;
                    ctx.font = `${fontSize}px "Press Start 2P"`;
                }
                ctx.fillText(gameState.compromiseMessage, canvas.width / 2, bannerY + fontSize/2);

                ctx.restore();
            }

            ctx.restore();
        }

        function drawTitleScreen() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw title image
            if (assets.images.title.complete) {
                ctx.drawImage(assets.images.title, 0, 0, canvas.width, canvas.height);
            }

            // Animated owl sprite (look_1 through look_6)
            const lookFrames = [assets.images.look1, assets.images.look2, assets.images.look3, assets.images.look4, assets.images.look5, assets.images.look6];
            const frameIdx = Math.floor(Date.now() / 150) % 6;
            const owlFrame = lookFrames[frameIdx];
            if (owlFrame && owlFrame.complete) {
                const owlSize = canvas.width * 0.38;
                const owlX = canvas.width / 2 - owlSize / 2;
                const owlY = canvas.height * 0.48;
                ctx.drawImage(owlFrame, owlX, owlY, owlSize, owlSize);
            }

            // Tap to start below owl â€” only show when audio is ready
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = '#0ff';
            const pulseA = 0.5 + 0.5 * Math.sin(Date.now() / 300);
            ctx.globalAlpha = pulseA;
            ctx.fillText('TAP TO START', canvas.width / 2, canvas.height * 0.78);
            ctx.globalAlpha = 1;

            // How to play button (left side of bottom)
            ctx.fillStyle = '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('HOW TO PLAY', canvas.width * 0.25, canvas.height * 0.95);

            // High scores button (right side of bottom)
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.fillText('HIGH SCORES', canvas.width * 0.75, canvas.height * 0.95);
        }

        function drawHowToPlay() {
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const s = Math.min(canvas.width, canvas.height) * 0.035; // responsive font base

            // Title
            ctx.fillStyle = '#0ff';
            ctx.font = `bold ${Math.round(s * 1.4)}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0ff';
            ctx.fillText('HOW TO PLAY', cx, s * 2.5);

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // Instructions with game sprites
            const iconSize = Math.round(s * 2.2);
            const startY = canvas.height * 0.14;
            const lineH = canvas.height * 0.085;
            const iconX = canvas.width * 0.15;
            const textX = canvas.width * 0.58;

            const lines = [
                { img: null, emoji: 'ðŸ‘†', color: '#00ff88', text: 'HOLD to walk' },
                { img: null, emoji: 'âœ‹', color: '#00ff88', text: 'RELEASE to jump' },
                { img: assets.images.coinSprite, color: '#ffd700', text: 'Collect ETH' },
                { img: assets.images.drainer, color: '#ff4444', text: 'Dodge drainers' },
                { img: null, emoji: 'ðŸ›¡ï¸', color: '#ffd700', text: 'Shield blocks' },
                { img: null, emoji: 'ðŸ§²', color: '#ff6600', text: 'Magnet pulls' },
                { img: null, emoji: 'ðŸŒ§ï¸', color: '#00ffcc', text: 'Coin rain!' },
                { img: 'owlHead', color: '#ff6688', text: '3 lives. Go!' },
            ];

            lines.forEach((line, i) => {
                const y = startY + i * lineH;
                // Draw sprite or emoji â€” owl head uses cropped look1
                if (line.img === 'owlHead' && assets.images.look1.complete) {
                    // Same crop as in-game lives HUD
                    const src = assets.images.look1;
                    const sw = src.naturalWidth, sh = src.naturalHeight;
                    const cropX = sw * 0.05, cropY = 0;
                    const cropW = sw * 0.9, cropH = sh * 0.58;
                    const headSize = iconSize * 2.112;
                    const drawH = headSize * (cropH / cropW);
                    ctx.drawImage(src, cropX, cropY, cropW, cropH,
                        iconX - headSize/2 + 2, y - drawH * 0.85 - 9, headSize, drawH);
                } else if (line.img && line.img.complete) {
                    ctx.drawImage(line.img, iconX - iconSize/2, y - iconSize * 0.6, iconSize, iconSize);
                } else if (line.emoji) {
                    ctx.font = `${Math.round(iconSize * 0.8)}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(line.emoji, iconX, y + iconSize * 0.15);
                }
                // Text
                ctx.font = `${Math.round(s * 0.85)}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.fillStyle = line.color;
                ctx.fillText(line.text, textX, y);
            });

            // Tap to start â€” raised higher
            ctx.fillStyle = '#0ff';
            ctx.font = `${Math.round(s)}px "Press Start 2P"`;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#0ff';
            const pulseAlpha = 0.5 + 0.5 * Math.sin(Date.now() / 300);
            ctx.globalAlpha = pulseAlpha;
            ctx.fillText('TAP TO START', cx, canvas.height - s * 6);
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // YOU GOT RUGGED - big glitchy red text
            ctx.fillStyle = '#ff0000';
            ctx.font = '28px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff0000';

            // Glitchy effect
            const glitchOffset = Math.random() * 4 - 2;
            ctx.fillText('YOU GOT', canvas.width / 2 + glitchOffset, canvas.height * 0.25);
            ctx.fillText('RUGGED', canvas.width / 2 - glitchOffset, canvas.height * 0.35);

            // Score
            ctx.fillStyle = '#0ff';
            ctx.font = '20px "Press Start 2P"';
            ctx.shadowColor = '#0ff';
            ctx.shadowBlur = 15;
            ctx.fillText(`SCORE: ${gameState.score}`, canvas.width / 2, canvas.height * 0.5);

            // New high score
            if (isHighScore(gameState.score)) {
                ctx.fillStyle = '#ffd700';
                ctx.font = '16px "Press Start 2P"';
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, canvas.height * 0.6);
            }

            // Tap to continue
            ctx.fillStyle = '#00ff00';
            ctx.font = '14px "Press Start 2P"';
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.fillText('TAP TO CONTINUE', canvas.width / 2, canvas.height * 0.75);
        }

        function drawHighScores() {
            // Dark cyberpunk background
            ctx.fillStyle = '#0a0015';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title with underline
            ctx.fillStyle = '#0ff';
            ctx.font = '20px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0ff';
            ctx.fillText('GLOBAL HIGH SCORES', canvas.width / 2, 50);

            // Underline
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width * 0.2, 60);
            ctx.lineTo(canvas.width * 0.8, 60);
            ctx.stroke();

            // High score entries - each in DIFFERENT COLOR
            ctx.font = '14px "Press Start 2P"';
            gameState.highScores.forEach((entry, i) => {
                const y = 100 + i * 35;
                // Highlight new high score
                if (i === gameState.newHighScoreIndex) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(0, y - 20, canvas.width, 30);
                }

                // All entries bright yellow
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 8;

                // Rank number
                ctx.textAlign = 'left';
                ctx.fillText(`${i + 1}.`, 30, y);

                // Initials
                ctx.fillText(entry.initials, 80, y);

                // Score
                ctx.textAlign = 'right';
                ctx.fillText(entry.score.toString(), canvas.width - 30, y);
            });

            // Back button
            ctx.fillStyle = '#ff0000';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ff0000';
            ctx.fillText('TAP TO RETURN', canvas.width / 2, canvas.height - 30);
        }

        function drawEnterInitials() {
            // Dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = '18px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffd700';
            ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, 80);

            // Score
            ctx.fillStyle = '#0ff';
            ctx.font = '16px "Press Start 2P"';
            ctx.shadowColor = '#0ff';
            ctx.fillText(`SCORE: ${gameState.score}`, canvas.width / 2, 120);

            // Instructions
            ctx.fillStyle = '#fff';
            ctx.font = '10px "Press Start 2P"';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#fff';
            ctx.fillText('TAP LETTERS TO CYCLE A-Z', canvas.width / 2, 160);

            // Draw three large letters (tap each to cycle)
            const letterSpacing = 80;
            const startX = canvas.width / 2 - letterSpacing;
            const letterY = 240;

            initialsInput.blinkTimer += 16;
            const blink = Math.floor(initialsInput.blinkTimer / 500) % 2 === 0;

            for (let i = 0; i < 3; i++) {
                const x = startX + i * letterSpacing;

                // Box for letter â€” all bright yellow
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffff00';
                ctx.strokeRect(x - 30, letterY - 45, 60, 60);

                // Letter â€” bright yellow with glow
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffff00';
                ctx.font = '36px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(initialsInput.letters[i], x, letterY);
            }

            // SUBMIT button (green)
            const submitY = 340;
            ctx.fillStyle = '#00ff00';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff00';
            ctx.fillRect(canvas.width / 2 - 100, submitY, 200, 50);

            ctx.fillStyle = '#000';
            ctx.font = '14px "Press Start 2P"';
            ctx.shadowBlur = 0;
            ctx.fillText('SUBMIT', canvas.width / 2, submitY + 32);
        }

        // ==========================================
        // GAME LOOP
        // ==========================================

        let lastTime = performance.now();

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Apply screen shake
            if (gameState.screenShake > 0) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
                gameState.screenShake *= 0.9;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            switch (currentState) {
                case GAME_STATE.TITLE:
                    drawTitleScreen();
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    drawHowToPlay();
                    break;

                case GAME_STATE.PLAYING:
                    // Update physics
                    updatePhysics(deltaTime);

                    // Animation speed based on state
                    let animRate;
                    if (gameState.isWalking) {
                        animRate = deltaTime * 0.01;  // Walk: ~10fps
                    } else if (!gameState.grounded) {
                        animRate = deltaTime * 0.008;  // Jumping: ~8fps
                    } else {
                        animRate = deltaTime * 0.003;  // Idle bounce: slow gentle
                    }
                    gameState.playerAnimFrame += animRate;

                    updateGameSpeed(deltaTime);
                    spawnObject();

                    gameState.objects.forEach(obj => obj.update(deltaTime));
                    checkCollisions();

                    if (gameState.magnet) {
                        gameState.magnetTimer -= deltaTime;
                        if (gameState.magnetTimer <= 0) {
                            gameState.magnet = false;
                        }
                    }

                    // Draw
                    drawBackground();
                    gameState.objects.forEach(obj => obj.draw());
                    drawPlayer();

                    // Last life intensity - subtle red vignette pulse
                    if (gameState.lives === 1) {
                        const pulseAlpha = 0.06 + 0.04 * Math.sin(Date.now() / 400);
                        const vGrad = ctx.createRadialGradient(
                            canvas.width/2, canvas.height * PHYSICS.GAME_AREA_RATIO / 2, canvas.width * 0.3,
                            canvas.width/2, canvas.height * PHYSICS.GAME_AREA_RATIO / 2, canvas.width * 0.8
                        );
                        vGrad.addColorStop(0, 'rgba(255, 0, 0, 0)');
                        vGrad.addColorStop(1, `rgba(255, 0, 0, ${pulseAlpha})`);
                        ctx.fillStyle = vGrad;
                        ctx.fillRect(0, 0, canvas.width, canvas.height * PHYSICS.GAME_AREA_RATIO);
                    }

                    // (milestone flash removed)

                    // Speed wind lines when going fast
                    if (gameState.bgSpeed > 10) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.lineWidth = 1;
                        const t = Date.now();
                        for (let i = 0; i < 4; i++) {
                            const ly = ((i * 173 + t * 0.03) % (canvas.height * 0.7)) + 20;
                            const lx = (t * (0.8 + i * 0.2)) % canvas.width;
                            ctx.beginPath();
                            ctx.moveTo(lx, ly);
                            ctx.lineTo(lx - 60 - gameState.bgSpeed * 4, ly);
                            ctx.stroke();
                        }
                    }

                    drawUI();
                    break;

                case GAME_STATE.GAME_OVER:
                    drawGameOverScreen();
                    break;

                case GAME_STATE.HIGH_SCORES:
                    drawHighScores();
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    drawEnterInitials();
                    break;
            }

            if (gameState.screenShake > 0) {
                ctx.restore();
            }

            requestAnimationFrame(gameLoop);
        }

        // ==========================================
        // INPUT HANDLING - CRITICAL: Hold to walk, Release to jump
        // ==========================================

        let touchActive = false;

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            enableAudio();

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            switch (currentState) {
                case GAME_STATE.TITLE:
                    if (y > canvas.height * 0.9 && x < canvas.width * 0.5) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else if (y > canvas.height * 0.9 && x >= canvas.width * 0.5) {
                        currentState = GAME_STATE.HIGH_SCORES;
                    } else if (!localStorage.getItem('etherDashTutorialSeen')) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else {
                        resetGame();
                        currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    }
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    localStorage.setItem('etherDashTutorialSeen', '1');
                    resetGame();
                    currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    break;

                case GAME_STATE.PLAYING:
                    // HOLD = WALK
                    startHolding();
                    touchActive = true;
                    break;

                case GAME_STATE.GAME_OVER:
                    if (isHighScore(gameState.score)) {
                        initialsInput = { letters: ['A', 'A', 'A'], currentIndex: 0, blinkTimer: 0 };
                        currentState = GAME_STATE.ENTER_INITIALS;
                    } else {
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;

                case GAME_STATE.HIGH_SCORES:
                    currentState = GAME_STATE.TITLE;
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    // Check which letter was tapped
                    const letterSpacing = 80;
                    const startX = canvas.width / 2 - letterSpacing;
                    const letterY = 240;

                    for (let i = 0; i < 3; i++) {
                        const lx = startX + i * letterSpacing;
                        if (x > lx - 30 && x < lx + 30 && y > letterY - 45 && y < letterY + 15) {
                            cycleInitialLetter(i);
                            break;
                        }
                    }

                    // Check submit button
                    const submitY = 340;
                    if (y > submitY && y < submitY + 50 && x > canvas.width / 2 - 100 && x < canvas.width / 2 + 100) {
                        const initials = initialsInput.letters.join('');
                        addHighScore(initials, gameState.score);
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();

            // RELEASE = JUMP
            if (currentState === GAME_STATE.PLAYING && touchActive) {
                releaseHolding();
                touchActive = false;
            }
        }, { passive: false });

        // Mouse events for desktop testing
        canvas.addEventListener('mousedown', (e) => {
            enableAudio();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            switch (currentState) {
                case GAME_STATE.TITLE:
                    if (y > canvas.height * 0.9 && x < canvas.width * 0.5) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else if (y > canvas.height * 0.9 && x >= canvas.width * 0.5) {
                        currentState = GAME_STATE.HIGH_SCORES;
                    } else if (!localStorage.getItem('etherDashTutorialSeen')) {
                        currentState = GAME_STATE.HOW_TO_PLAY;
                    } else {
                        resetGame();
                        currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    }
                    break;

                case GAME_STATE.HOW_TO_PLAY:
                    localStorage.setItem('etherDashTutorialSeen', '1');
                    resetGame();
                    currentState = GAME_STATE.PLAYING; stopMusic(); startMusic();
                    break;

                case GAME_STATE.PLAYING:
                    startHolding();
                    touchActive = true;
                    break;

                case GAME_STATE.GAME_OVER:
                    if (isHighScore(gameState.score)) {
                        initialsInput = { letters: ['A', 'A', 'A'], currentIndex: 0, blinkTimer: 0 };
                        currentState = GAME_STATE.ENTER_INITIALS;
                    } else {
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;

                case GAME_STATE.HIGH_SCORES:
                    currentState = GAME_STATE.TITLE;
                    break;

                case GAME_STATE.ENTER_INITIALS:
                    const letterSpacing = 80;
                    const startX = canvas.width / 2 - letterSpacing;
                    const letterY = 240;

                    for (let i = 0; i < 3; i++) {
                        const lx = startX + i * letterSpacing;
                        if (x > lx - 30 && x < lx + 30 && y > letterY - 45 && y < letterY + 15) {
                            cycleInitialLetter(i);
                            break;
                        }
                    }

                    const submitY = 340;
                    if (y > submitY && y < submitY + 50 && x > canvas.width / 2 - 100 && x < canvas.width / 2 + 100) {
                        const initials = initialsInput.letters.join('');
                        addHighScore(initials, gameState.score);
                        currentState = GAME_STATE.HIGH_SCORES;
                    }
                    break;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (currentState === GAME_STATE.PLAYING && touchActive) {
                releaseHolding();
                touchActive = false;
            }
        });

        // Keyboard controls for desktop testing
        let keyHeld = false;
        document.addEventListener('keydown', (e) => {
            if (currentState === GAME_STATE.PLAYING) {
                if ((e.key === ' ' || e.key === 'ArrowDown' || e.key === 's') && !keyHeld) {
                    e.preventDefault();
                    startHolding();
                    keyHeld = true;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (currentState === GAME_STATE.PLAYING) {
                if (e.key === ' ' || e.key === 'ArrowDown' || e.key === 's') {
                    e.preventDefault();
                    releaseHolding();
                    keyHeld = false;
                }
            }
        });

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
